<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-site-verification" content="fgTBOMeN_sdI4JNBqYTzDwH0458H8AAVbF78jLjwudg" />
  <script type="text/javascript" src="/assets/vendor/moment.min.js"></script>
  <script type="text/javascript" src="/assets/js/site.js"></script>
  <!-- <script src="https://unpkg.com/cursor-effects@latest/dist/browser.js"></script> -->

  <title>
    
      Trie
    
  </title>

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Trie" />
<meta name="author" content="sangwoo-joh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="문자열을 비교하고 검색하는 알고리즘은 항상 중요하다. 뭐 여러가지 알고리즘이 많은데 요즘 가장 재밌게 구현한 알고리즘은 단연 트라이 다(트리가 아니다!). TRIE는 Edward Fredkin이 만들었고 reTRIEval이라는 단어에서 따왔다고 한다. 태생이 검색을 위한 놈이다. 간단히 설명하면 트리 모양을 한 결정적 유한 오토마타다." />
<meta property="og:description" content="문자열을 비교하고 검색하는 알고리즘은 항상 중요하다. 뭐 여러가지 알고리즘이 많은데 요즘 가장 재밌게 구현한 알고리즘은 단연 트라이 다(트리가 아니다!). TRIE는 Edward Fredkin이 만들었고 reTRIEval이라는 단어에서 따왔다고 한다. 태생이 검색을 위한 놈이다. 간단히 설명하면 트리 모양을 한 결정적 유한 오토마타다." />
<link rel="canonical" href="https://sangwoo-joh.github.io/trie" />
<meta property="og:url" content="https://sangwoo-joh.github.io/trie" />
<meta property="og:site_name" content="Caml Shaving" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-23T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Trie" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sangwoo-joh"},"dateModified":"2018-08-23T00:00:00+00:00","datePublished":"2018-08-23T00:00:00+00:00","description":"문자열을 비교하고 검색하는 알고리즘은 항상 중요하다. 뭐 여러가지 알고리즘이 많은데 요즘 가장 재밌게 구현한 알고리즘은 단연 트라이 다(트리가 아니다!). TRIE는 Edward Fredkin이 만들었고 reTRIEval이라는 단어에서 따왔다고 한다. 태생이 검색을 위한 놈이다. 간단히 설명하면 트리 모양을 한 결정적 유한 오토마타다.","headline":"Trie","mainEntityOfPage":{"@type":"WebPage","@id":"https://sangwoo-joh.github.io/trie"},"url":"https://sangwoo-joh.github.io/trie"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="https://sangwoo-joh.github.io/feed.xml" title="Caml Shaving" />

  <link rel="apple-touch-icon" sizes="57x57" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="https://sangwoo-joh.github.io/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://sangwoo-joh.github.io/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="https://sangwoo-joh.github.io/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://sangwoo-joh.github.io/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="https://sangwoo-joh.github.io/assets/icons/manifest.json">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Ubuntu" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Open+Sans" />
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <link rel="stylesheet" href="https://sangwoo-joh.github.io/assets/css/main.css" />
  <link rel="stylesheet" href="https://sangwoo-joh.github.io/assets/css/syntax.css" />
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J0C68FHJ6L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J0C68FHJ6L');
</script>


</head>
<body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="https://sangwoo-joh.github.io">/home/caml-shaving</a>
<center>
<h1>Trie</h1>
<h2>트리가 아니라 트라이</h2>
</center>

<div class="post-edit-date">
  
  2018-08-23
</div>

<div class="post-edit-date">
  
  
</div>

<em><p align="right">

태그:



<a href="/archive?tag=dev"><span class="tag">dev</span></a>




</p></em>


<p>문자열을 비교하고 검색하는 알고리즘은 항상 중요하다. 뭐 여러가지
 알고리즘이 많은데 요즘 가장 재밌게 구현한 알고리즘은 단연 <strong>트라이</strong>
 다(<em>트리</em>가 아니다!). TRIE는 <a href="https://en.wikipedia.org/wiki/Edward_Fredkin">Edward
 Fredkin</a>이 만들었고
 re<strong>TRIE</strong>val이라는 단어에서 따왔다고 한다. 태생이 검색을 위한
 놈이다. 간단히 설명하면 트리 모양을 한 결정적 유한 오토마타다.</p>

<p>문자열을 키로 어떤 데이터를 관리해야 하는 상황에서 데이터의 추가/
 검색이 잦은 경우 고려해볼만 한 자료구조다. 대신 문자(character)
 하나에 트리의 엣지 하나가 대응되기 때문에, 메모리를 많이 못쓰는
 경우에는 쓸 수 없다. 적당히 데이터의 키가 소문자로만 이뤄진 경우,
 그러니까 기껏해야 26자만 필요한 경우에는 꽤 유용하게 쓸 수 있다.</p>

<p>트라이로 문자열 관련 문제를 풀면 해쉬 같은 방법에 비해 속도가
 엄청나게 빨라진다. 해쉬는 항상 충돌의 위험이 있어서 해쉬 값이 같으면
 더블 체크를 해줘야 하기 때문에.</p>

<p>트라이로 풀 수 있는 문제 중에 재밌는 건 간단한 디렉토리 커맨드
 구현이다. 리눅스의 <code class="language-plaintext highlighter-rouge">ls</code>, <code class="language-plaintext highlighter-rouge">mkdir</code>, <code class="language-plaintext highlighter-rouge">rm</code>, <code class="language-plaintext highlighter-rouge">cd</code> 키워드를 구현해보자.</p>

<p>일단 두 가지 자료구조를 쓸거다. 하나는 트라이고 하나는 유사
 <a href="https://en.wikipedia.org/wiki/Inode">inode</a>이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">INode</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Trie</span><span class="p">{</span>
  <span class="n">Trie</span> <span class="o">*</span><span class="n">children</span><span class="p">[</span><span class="mi">26</span><span class="p">];</span> <span class="c1">// lower-case only</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="c1">// count of reference</span>
  <span class="kt">bool</span> <span class="n">valid</span><span class="p">;</span> <span class="c1">// for fast remove</span>
  <span class="n">INode</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span> <span class="c1">// only valid when terminal</span>
<span class="p">};</span>
</code></pre></div></div>

<p>트라이는 간단하다. 일단 소문자만 사용하기 때문에 각 엣지(소문자)에
 대응할 26개의 자식 포인터가 있다. count 는 참조 횟수로, 예를 들어
 현재 디렉토리에 a와 ab라는 디렉토리 두개가 있으면, a 엣지의 카운트는
 2이고 a 노드의 b 엣지 카운트는 1이 되게끔 할 거다. valid는 빠른
 삭제를 위한 플래그이고, dir는 실제로 트라이의 끝에 매달릴 inode
 포인터이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">INode</span><span class="p">{</span>
  <span class="n">INode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
  <span class="n">Trie</span> <span class="o">*</span><span class="n">sub</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>유사 아이노드는 실제 디렉토리 정보를 담을 자료구조다. <code class="language-plaintext highlighter-rouge">cd ..</code>
 커맨드를 위해서 부모 디렉토리의 포인터도 하나 갖고 있고, 현재
 디렉토리의 자식 디렉토리를 관리하기 위한 트라이 sub도 갖고
 있다. 그리고 size는 자식 디렉토리의 개수가 아니라, 자식 디렉토리의
 개수와 그 각각의 자식 디렉토리 안의 모든 자식 디렉토리 개수를 다 합친
 값이다.</p>

<p>이렇게하면 일단 디렉토리 중복체크를 다음과 같이 O(1)만에 확인할 수
 있다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">conflict</span><span class="p">(</span><span class="n">Trie</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">){</span>
  <span class="n">Trie</span> <span class="o">*</span><span class="n">trie</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">t_idx</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
	  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">];</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
	  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="o">++</span><span class="n">idx</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>쉽다. 중복체크할 디렉토리 이름의 문자열 하나하나를 가지고 현재
 디렉토리의 sub(트라이)를 쭈욱 따라서 하나하나 확인해보면 된다. 엣지가
 없거나 유효하지 않으면 <code class="language-plaintext highlighter-rouge">false</code>(노중복)다. 완전히 이름이 같은 경우
 해당 트라이에 매달린 디렉토리가 있는지를(<code class="language-plaintext highlighter-rouge">trie-&gt;dir</code>이 널인지) 보면
 된다.</p>

<p>이 중복체크 함수를 가지고 <code class="language-plaintext highlighter-rouge">mkdir</code> 함수를 만들면 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">mkdir</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">conflict</span><span class="p">(</span><span class="n">wd</span><span class="o">-&gt;</span><span class="n">sub</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="n">Trie</span> <span class="o">*</span><span class="n">trie</span> <span class="o">=</span> <span class="n">wd</span><span class="o">-&gt;</span><span class="n">sub</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">){</span>
	  <span class="kt">int</span> <span class="n">t_idx</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
	  <span class="k">if</span><span class="p">(</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
	    <span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">trie_pool</span><span class="p">.</span><span class="n">alloca</span><span class="p">();</span>
	  <span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">];</span>
	  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
	  <span class="n">trie</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	  <span class="o">++</span><span class="n">idx</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">trie</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="n">inode_pool</span><span class="p">.</span><span class="n">alloca</span><span class="p">();</span>
	<span class="n">trie</span><span class="o">-&gt;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">wd</span><span class="p">;</span>
	<span class="n">propagate_inode_count</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>먼저 중복체크를 하고, 중복이 없는 경우 디렉토리 문자열을 가지고
 하나하나 따라가면서 엣지가 없으면 만들고, 삭제됐으면 초기화하고,
 있으면 레퍼런스를 1씩 늘려준다. 최종적으로 디렉토리 이름을 다
 따라갔으면 진짜 디렉토리를 뜻하는 아이노드를 만들어서 매달아주고 해당
 아이노드의 부모 디렉토리를 지금의 작업 디렉토리(wd; working
 directory)로 만든다. 마지막으로 <code class="language-plaintext highlighter-rouge">ls</code>와 <code class="language-plaintext highlighter-rouge">rm</code> 커맨드를 위해 현재로부터
 루트까지 모든 부모 디렉토리에게 개수 증가 1을 전파한다. 전파 함수는
 아래와 같이 매우 쉽다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">propagate_inode_count</span><span class="p">(</span><span class="n">INode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">acc</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">acc</span><span class="p">;</span>
  <span class="n">propagate_inode_count</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">acc</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>작업 디렉토리를 바꾸는 <code class="language-plaintext highlighter-rouge">cd</code> 함수는 다음과 같이 짜면 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">cd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="s">"/"</span><span class="p">){</span>
    <span class="n">wd</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="s">".."</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">wd</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">else</span><span class="p">{</span>
	  <span class="n">wd</span> <span class="o">=</span> <span class="n">wd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="n">Trie</span> <span class="o">*</span><span class="n">trie</span> <span class="o">=</span> <span class="n">wd</span><span class="o">-&gt;</span><span class="n">sub</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\t'</span><span class="p">){</span>
	  <span class="kt">int</span> <span class="n">t_idx</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
	  <span class="k">if</span><span class="p">(</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	  <span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">];</span>
	  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	  <span class="o">++</span><span class="n">idx</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span><span class="p">(</span><span class="n">trie</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">){</span>
	  <span class="n">Trie</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
	  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	    <span class="k">if</span><span class="p">(</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">){</span>
		  <span class="n">next</span> <span class="o">=</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		  <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	  <span class="n">trie</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">trie</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">wd</span> <span class="o">=</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>역시 트라이는 명확한 자료구조라 쉽게 구현할 수 있다. <code class="language-plaintext highlighter-rouge">cd</code>의 경우 탭
 키가 있으면 알파벳 순으로 가장 빠른 자식 디렉토리로 가도록 하기
 위해서 추가적인 검색을 더 했다.</p>

<p>모든 자식 디렉토리 및 자식 디렉토리의 리프 디렉토리의 개수를 반환하기
 위한 <code class="language-plaintext highlighter-rouge">ls</code>는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">ls</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="s">"*"</span><span class="p">)</span> <span class="k">return</span> <span class="n">wd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
  <span class="n">Trie</span> <span class="o">*</span><span class="n">trie</span> <span class="o">=</span> <span class="n">wd</span><span class="o">-&gt;</span><span class="n">sub</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'*'</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">t_idx</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">];</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">++</span><span class="n">idx</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">ls_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">ls_cnt</span> <span class="o">+=</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
  <span class="n">retrieve_all_subdir</span><span class="p">(</span><span class="n">trie</span><span class="p">,</span> <span class="n">ls_cnt</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ls_cnt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>역시 비슷하게 디렉토리 이름을 가지고 트라이를 하나하나 따라가고(이거
 자꾸 비슷한 funcionality가 중복되는 기분이 드는데 어떻게하면 깔끔하게
 중복을 제거할 수 있을지 좀더 고민해봐야겠다), <code class="language-plaintext highlighter-rouge">*</code>을 만나면 이제
 거기서부터 최종 개수를 센다. 먼저 <code class="language-plaintext highlighter-rouge">*</code> 이전까지의 문자열의 참조 개수,
 즉 현재 디렉토리가 갖고 있는 자식 디렉토리의 개수를 세고, 거기다 해당
 이름으로 시작하는 모~~~든 자식 디렉토리의 개수를 누적하면
 된다. 우리는 아이노드의 <code class="language-plaintext highlighter-rouge">size</code>에 이를 잘 캐싱해뒀기 때문에 다음과
 같이 하면 쉽게 구할 수 있다!</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">retrieve_all_subdir</span><span class="p">(</span><span class="n">Trie</span> <span class="o">*</span><span class="n">sub</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">acc</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="n">acc</span> <span class="o">+=</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span>
	  <span class="n">retrieve_all_subdir</span><span class="p">(</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">acc</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 남은 건 디렉토리를 삭제하고 삭제 개수를 반환하는 <code class="language-plaintext highlighter-rouge">rm</code>이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">rm</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="s">"*"</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
	  <span class="k">if</span><span class="p">(</span><span class="n">wd</span><span class="o">-&gt;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
	    <span class="n">wd</span><span class="o">-&gt;</span><span class="n">sub</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">propagate_inode_count</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">wd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">rm_cnt</span> <span class="o">=</span> <span class="n">wd</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">wd</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rm_cnt</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Trie</span> <span class="o">*</span><span class="n">trie</span> <span class="o">=</span> <span class="n">wd</span><span class="o">-&gt;</span><span class="n">sub</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'*'</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">t_idx</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">];</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">++</span><span class="n">idx</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">cur_dir_rm_cnt</span> <span class="o">=</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">all_subdir_rm_cnt</span> <span class="o">=</span> <span class="n">cur_dir_rm_cnt</span><span class="p">;</span>
  <span class="n">retrieve_all_subdir</span><span class="p">(</span><span class="n">trie</span><span class="p">,</span> <span class="n">all_subdir_rm_cnt</span><span class="p">);</span>

  <span class="n">trie</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">trie</span> <span class="o">=</span> <span class="n">wd</span><span class="o">-&gt;</span><span class="n">sub</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'*'</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">t_idx</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
	<span class="n">trie</span> <span class="o">=</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">t_idx</span><span class="p">];</span>
	<span class="n">trie</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">-=</span> <span class="n">cur_dir_rm_cnt</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">trie</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">trie</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="o">++</span><span class="n">idx</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">propagate_inode_count</span><span class="p">(</span><span class="n">wd</span><span class="p">,</span> <span class="o">-</span><span class="n">all_subdir_rm_cnt</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">all_subdir_rm_cnt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이때까지 만든 함수들을 적절히 이용해서 짜깁기하면 쉽다. 삭제할 때 (1)
 트라이 및 디렉토리 삭제, (2) 삭제한 개수 캐싱 이 두 가지만 제대로
 하면 된다. 다 삭제하는 경우는 쉬우니 검색하는 경우를 보면 일단 원하는
 트라이까지 따라오고 나면 해당 트라이의 참조 회수가 곧 <em>현재
 디렉토리에서 지워야하는 서브 디렉토리의 개수</em>이다. 일단 이걸
 캐싱하고, 나머지는 <strong>이 서브 디렉토리가 갖고 있는 모든 서브
 디렉토리의 개수</strong>를 갖고 와서 빼야 한다. <code class="language-plaintext highlighter-rouge">ls</code> 만들 때 썼던 함수를
 갖다 쓰면 쉽게 해결된다.</p>


<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<br />

<div>
  <script src="https://giscus.app/client.js"
          data-repo="sangwoo-joh/reactions"
          data-repo-id="R_kgDOJFNVQw"
          data-category="Comments"
          data-category-id="DIC_kwDOJFNVQ84CUox9"
          data-mapping="pathname"
          data-strict="1"
          data-reactions-enabled="1"
          data-emit-metadata="0"
          data-input-position="bottom"
          data-theme="light_high_contrast"
          data-lang="ko"
          data-loading="lazy"
          crossorigin="anonymous"
          async>
  </script>
</div>

<br />

      </div>
    </main>

    
    <footer>
  <a href="/feed.xml">rss</a>
  <a href="mailto:work.sangwoo.joh@gmail.com">mail</a>
  <a href="https://www.linkedin.com/in/sangwoo-joh">linkedin</a>
  <a href="https://github.com/sangwoo-joh">github</a>
  <p class="copyright text-muted">Copyright &copy; sangwoo-joh 2023</p>
  <small><a target="_blank" href="https://icons8.com/icons/set/--camel">Camel icon</a> icon by <a target="_blank" href="https://icons8.com">Icons8</a></small>
</footer>

  </body>
</html>
