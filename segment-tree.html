<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-site-verification" content="fgTBOMeN_sdI4JNBqYTzDwH0458H8AAVbF78jLjwudg" />
  <script type="text/javascript" src="/assets/vendor/moment.min.js"></script>
  <script type="text/javascript" src="/assets/js/site.js"></script>
  <!-- <script src="https://unpkg.com/cursor-effects@latest/dist/browser.js"></script> -->

  <title>
    
      세그먼트 트리
    
  </title>

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="세그먼트 트리" />
<meta name="author" content="sangwoo-joh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="알고리즘 준비를 하다가 만난 문제다. 주어진 배열에서," />
<meta property="og:description" content="알고리즘 준비를 하다가 만난 문제다. 주어진 배열에서," />
<link rel="canonical" href="https://sangwoo-joh.github.io/segment-tree" />
<meta property="og:url" content="https://sangwoo-joh.github.io/segment-tree" />
<meta property="og:site_name" content="Caml Shaving" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-21T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="세그먼트 트리" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sangwoo-joh"},"dateModified":"2018-07-21T00:00:00+00:00","datePublished":"2018-07-21T00:00:00+00:00","description":"알고리즘 준비를 하다가 만난 문제다. 주어진 배열에서,","headline":"세그먼트 트리","mainEntityOfPage":{"@type":"WebPage","@id":"https://sangwoo-joh.github.io/segment-tree"},"url":"https://sangwoo-joh.github.io/segment-tree"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="https://sangwoo-joh.github.io/feed.xml" title="Caml Shaving" />

  <link rel="apple-touch-icon" sizes="57x57" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="https://sangwoo-joh.github.io/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://sangwoo-joh.github.io/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="https://sangwoo-joh.github.io/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://sangwoo-joh.github.io/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="https://sangwoo-joh.github.io/assets/icons/manifest.json">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Ubuntu" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Open+Sans" />
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <link rel="stylesheet" href="https://sangwoo-joh.github.io/assets/css/main.css" />
  <link rel="stylesheet" href="https://sangwoo-joh.github.io/assets/css/syntax.css" />
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J0C68FHJ6L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J0C68FHJ6L');
</script>


</head>
<body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="https://sangwoo-joh.github.io">/home/caml-shaving</a>
<center>
<h1>세그먼트 트리</h1>
<h2>자료 구조란 어려워</h2>
</center>

<div class="post-edit-date">
  
  2018-07-21
</div>

<div class="post-edit-date">
  
  
</div>

<em><p align="right">

태그:



<a href="/archive?tag=dev"><span class="tag">dev</span></a>




</p></em>


<p>알고리즘 준비를 하다가 만난 문제다. 주어진 배열에서,</p>

<ol>
  <li>어떤 구간의 합을 구하는 쿼리</li>
  <li>i번째 원소를 업데이트하는 쿼리</li>
</ol>

<p>이 두 종류의 쿼리를 주어진 횟수만큼 시행해야 하는 상황이 있다고
 하자. 나이브하게 접근하면 1번 구간 합은 O(N), 2번 업데이트에 O(1)이
 걸리므로 K번 시행한다고 하면 O(KN)의 복잡도를 갖는다.</p>

<p>업데이트 쿼리가 없다면 그저 부분합을 저장해뒀다가 돌려주는 방식으로
 O(1)만에 가능하다. 그러나 원소가 업데이트 되어야 한다면, 해당 원소가
 포함되는 모든 부분합을 다 업데이트 해줘야 하므로 결국 O(N)이 걸린다.</p>

<p>이럴 때 정답은 [<strong>세그먼트 트리</strong>] 이다.</p>

<p>세그먼트 트리는 트리의 성질을 활용해서 위의 두 쿼리를 모두
 O(logN)만에 해치워 버릴 수 있게 도와주는 자료구조이다.</p>

<p>기본은 Complete Binary Tree의 array index 계산 방법을
 가져온다. Complete Binary Tree를 array로 구현하면, 어떤 node index
 i의 부모는 <code class="language-plaintext highlighter-rouge">i/2</code>, 왼쪽 자식은 <code class="language-plaintext highlighter-rouge">2*i</code>, 오른쪽 자식은 <code class="language-plaintext highlighter-rouge">2*i+1</code>이 된다(단,
 index가 1부터 시작하는 경우에만 해당).</p>

<p>이걸 이용해서 루트는 전체를 담고, 루트의 자식들은 전체의 반반씩을
 담고, 또 반반씩을 담고… 하는 식으로 쭈욱 가다보면 리프에는 그냥
 array element 하나를 담게 된다. 그러면 대충 init 함수 모양은 이렇게
 될 것이다:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">u</span><span class="p">)</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
  <span class="k">else</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">init</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">init</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">id</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>공간을 좀 낭비하긴 하지만 (대략 원래 array 크기의 4배로 잡으면 ㅇㅋ),
 이렇게 구조를 잡아두면 합/업데이트를 다음과 같이 계산할 수 있다:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">query_l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">query_u</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">query_l</span> <span class="o">&gt;</span> <span class="n">u</span> <span class="o">||</span> <span class="n">query_u</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">query_l</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="o">&amp;&amp;</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="n">query_r</span><span class="p">)</span> <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">query_l</span><span class="p">,</span> <span class="n">query_u</span><span class="p">)</span>
       <span class="o">+</span> <span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">id</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">query_l</span><span class="p">,</span> <span class="n">query_u</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u_idx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u_delta</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">u_idx</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="o">||</span> <span class="n">u_idx</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="n">tree</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">u_delta</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">u</span><span class="p">){</span>
    <span class="n">update</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">u_idx</span><span class="p">,</span> <span class="n">u_delta</span><span class="p">);</span>
	<span class="n">update</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">id</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_idx</span><span class="p">,</span> <span class="n">u_delta</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">update</code>에서 업데이트 하는 배열 원소의 값 자체가 아니라 값의 변화
 값(<code class="language-plaintext highlighter-rouge">u_delta</code>)을 넘기는 것에 유의해야 한다. 그렇게 해야 바뀌는 원소가
 영향을 주는 모든 구간(노드)에 값을 전파하기 편하기 때문이다. 그리고
 이 업데이트 함수는 <strong>세그먼트 트리</strong>를 업데이트 하는 함수임을
 주의해야 한다. <strong>실제 배열 원소는 따로 업데이트 해줘야한다!!</strong>
 그러니까, 예를 들어 <code class="language-plaintext highlighter-rouge">update(1, 0, N-1, 3, new - array[3])</code>이 호출되면
 (즉 크기 N 짜리 배열의 4번째 원소(= index가 3)의 값이 new로 바뀌면),
 update 함수 호출 뒤에 <code class="language-plaintext highlighter-rouge">array[3] = new;</code>라고 따로 배열만 업데이트
 해주면 된다. 잊지말자. 우리는 지금 <strong>세그먼트 트리</strong>를 다루고 있을
 뿐, 원래의 배열은 건들지 않았다. 이걸 까먹어서 오답이 나는 경우가
 있었다.</p>

<p>마지막으로 주의할 점은 노드의 아이디를 계산할 때 <code class="language-plaintext highlighter-rouge">left = 2 * id</code>,
 <code class="language-plaintext highlighter-rouge">right = 2 * id + 1</code>로 계산했기 때문에, <code class="language-plaintext highlighter-rouge">init</code>, <code class="language-plaintext highlighter-rouge">update</code>, <code class="language-plaintext highlighter-rouge">sum</code>을
 호출할 때 루트 노드의 아이디를 1로 넘겨줘야 한다는 점이다. 예를 들어
 <code class="language-plaintext highlighter-rouge">array[N]</code> 즉 크기 N 짜리 배열로 값을 다룬다면, 세그먼트 트리를
 초기화 할 때는 <code class="language-plaintext highlighter-rouge">init(1, 0, N-1);</code>를 호출해주면 된다.</p>

<p>이제 우리는 큰 배열의 원소들이 연속적인 성질을 가질 때, 자주 원소가
 업데이트 되기도 하고 배열의 연속된 구간에 어떤 쿼리가 들어오기도 하는
 그런 상황에 적합한 자료 구조 하나를 알게 되었다. 이 포스트에는 구간의
 합을 예시로 들었지만 구간의 최대값/최소값을 저장한다던가 하는
 세그먼트 트리도 얼마든지 가능할 것이다.</p>


<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<br />

<div>
  <script src="https://giscus.app/client.js"
          data-repo="sangwoo-joh/reactions"
          data-repo-id="R_kgDOJFNVQw"
          data-category="Comments"
          data-category-id="DIC_kwDOJFNVQ84CUox9"
          data-mapping="pathname"
          data-strict="1"
          data-reactions-enabled="1"
          data-emit-metadata="0"
          data-input-position="bottom"
          data-theme="light_high_contrast"
          data-lang="ko"
          data-loading="lazy"
          crossorigin="anonymous"
          async>
  </script>
</div>

<br />

      </div>
    </main>

    
    <footer>
  <a href="/feed.xml">rss</a>
  <a href="mailto:work.sangwoo.joh@gmail.com">mail</a>
  <a href="https://www.linkedin.com/in/sangwoo-joh">linkedin</a>
  <a href="https://github.com/sangwoo-joh">github</a>
  <p class="copyright text-muted">Copyright &copy; sangwoo-joh 2023</p>
  <small><a target="_blank" href="https://icons8.com/icons/set/--camel">Camel icon</a> icon by <a target="_blank" href="https://icons8.com">Icons8</a></small>
</footer>

  </body>
</html>
