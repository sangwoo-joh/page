<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://sangwoo-joh.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://sangwoo-joh.github.io/" rel="alternate" type="text/html" /><updated>2023-11-03T02:40:30+00:00</updated><id>https://sangwoo-joh.github.io/feed.xml</id><title type="html">Caml Shaving</title><subtitle>Going Down The Rabbit Hole</subtitle><author><name>sangwoo-joh</name></author><entry><title type="html">쉽지 않다.</title><link href="https://sangwoo-joh.github.io/hidden-essay" rel="alternate" type="text/html" title="쉽지 않다." /><published>2023-10-31T00:00:00+00:00</published><updated>2023-10-31T00:00:00+00:00</updated><id>https://sangwoo-joh.github.io/hidden-essay</id><content type="html" xml:base="https://sangwoo-joh.github.io/hidden-essay"><![CDATA[<p>여러모로 올해는 쉽지 않은 해이다.</p>

<p>글을 쓰면 더욱 또렷해지는 기억이 무서워서 뭔가 잔뜩 적었다가 지웠다가를
 반복했다. 기록으로 남기는 것이 좋을지 아니면 아예 잊는게 좋을지 사실 잘
 모르겠기도 하다.</p>

<p>그래도 관성적인 습관 덕분에 버텨진다. 과거와 미래의 일은 생각하고 싶지도
 않지만, 어떻게든 하루를 살아나면 지나간다. 해야 할 일이 있다는 것은 그래서 좋은
 일이다.</p>

<p>이게 물리적으로 해결 불가능한 일이니까, 누군가한테 말하는 게 그래서 더욱
 꺼려진다. 말해봤자 어차피 해결할 수 없다. 아픔을 나누면 반이 된다는 말을 믿지
 않는다. 애초에 나눌 수도 없기 때문이다. 그렇게 점점 껍질 속에서 가라앉는다.
 시간이 해결해 줄 수 있기를 바란다.</p>

<p>이럴 때는 괜히 삶에 큰 변화를 주고 싶다. 하지만 동시에 그럴 의욕조차 나지
 않는다. 한 번도 겪어보지 못한 일이다. 어떻게 해야할지 솔직히 잘 모르겠다. 일단
 큰 돈을 한번 써봤는데 생각만큼 좋지 않았다. 뭘 더 해볼 수 있을지 찾아보고 있다.
 아, 그래서 다들 등산을 가나?</p>

<p>뭔가 하나에 흠뻑 빠져있고 싶다. 그냥 그거 하느라 아무 생각도 나지 않았으면
 좋겠다. 잘 해도 좋고 못 해도 좋다. 그런 걸 찾고 싶다.</p>]]></content><author><name>sangwoo-joh</name></author><category term="life" /><summary type="html"><![CDATA[여러모로 올해는 쉽지 않은 해이다.]]></summary></entry><entry><title type="html">Giscus</title><link href="https://sangwoo-joh.github.io/giscus" rel="alternate" type="text/html" title="Giscus" /><published>2023-03-04T00:00:00+00:00</published><updated>2023-03-04T00:00:00+00:00</updated><id>https://sangwoo-joh.github.io/giscus</id><content type="html" xml:base="https://sangwoo-joh.github.io/giscus"><![CDATA[<p><a href="https://giscus.app/ko">Giscus</a>란 걸 블로그에 연결했다.</p>
<p><a href="fear-to-write">작년 이맘때 즈음</a> 내가 쓴 글에 대한 반응을 마주하기가 두려워져서, 그간 써왔던
  디스커스를 버리고 간단한 리액션(하트)만 남길 수 있는 <a href="https://likebtn.com/en/">LikeBtn</a>을 달았었다. 하트만
  남기는 방식이 나쁘진 않았지만, 1년 정도 쓰다보니 몇 가지 아쉬운 점이 있었다.
  일단 <i>누가</i> 하트를 찍었는지 구분할 수 없다는 게 아쉬워지는 순간이 있었다.
  실명이나 닉네임을 알고 싶은 게 아니라, IP 단위로 사용자를 구분하다보니 내가
  여러 브라우저에서 테스트로 찍은 하트가 전부 따로 카운트되어서 일종의 어뷰징이
  가능한 게 아쉬웠다. 그리고 관련 통계를 보고 싶으면 반드시 결제를 해야하는 것이
  가장 큰 아쉬움이었다. 하트 반응의 추이는 볼 수 있었지만, 어느 글에 하트가 찍힌
  건지를 보기 위해서 매달 $5 (혹은 연 $13) 을 내고 싶지는 않았다.</p>
<p>그래서 취미 코딩 큐에 막연히 &#8216;대체재를 찾아서 갈아끼워야지&#8230;&#8217;란 생각만 하고
  있다가, SNS에서 스치듯 Giscus란 걸 보게 되었다. 살펴보니 <a href="https://utteranc.es/">Utterances</a>와 굉장히
  유사하지만 코멘트 뿐만 아니라 리액션을 따로 남길 수 있는 점이 끌렸다. 이름은
  Git + Disqus(랑 비슷) + (GitHub) Discussion 을 적절히 합친 것 같다. 그래서
  GitHub 저장소 하나를 씨드로 하고 여기에 Giscus 앱을 설치해서 GitHub의
  Discussion 기능을 활용하여 리액션과 코멘트를 관리하는 것으로 보인다. 한글
  지원도 잘 되는 것이 마음에 든다. Lazy loading도 지원해서 사이트 로딩이
  무거워지지 않아서(=그런 것처럼 느껴져서) 좋다.</p>
<p>예전에 찍혔던 하트가 날아간 것은 조금 아쉽지만, 훨씬 더 눈에 잘 들어오는
  리액션과 코멘트 박스가 생긴 것은 정말 마음에 든다. 거기다 내가 계정을 관리할
  필요 없이 깃허브 계정만 있으면 모든 것을 할 수 있다니. 오픈소스의 위대함을 다시
  한번 느낄 수 있었다.</p>
<p>이제 내가 글만 쓰면 된다&#8230;</p>]]></content><author><name>sangwoo-joh</name></author><category term="dev" /><summary type="html"><![CDATA[Giscus란 걸 블로그에 연결했다. 작년 이맘때 즈음 내가 쓴 글에 대한 반응을 마주하기가 두려워져서, 그간 써왔던 디스커스를 버리고 간단한 리액션(하트)만 남길 수 있는 LikeBtn을 달았었다. 하트만 남기는 방식이 나쁘진 않았지만, 1년 정도 쓰다보니 몇 가지 아쉬운 점이 있었다. 일단 누가 하트를 찍었는지 구분할 수 없다는 게 아쉬워지는 순간이 있었다. 실명이나 닉네임을 알고 싶은 게 아니라, IP 단위로 사용자를 구분하다보니 내가 여러 브라우저에서 테스트로 찍은 하트가 전부 따로 카운트되어서 일종의 어뷰징이 가능한 게 아쉬웠다. 그리고 관련 통계를 보고 싶으면 반드시 결제를 해야하는 것이 가장 큰 아쉬움이었다. 하트 반응의 추이는 볼 수 있었지만, 어느 글에 하트가 찍힌 건지를 보기 위해서 매달 $5 (혹은 연 $13) 을 내고 싶지는 않았다. 그래서 취미 코딩 큐에 막연히 &#8216;대체재를 찾아서 갈아끼워야지&#8230;&#8217;란 생각만 하고 있다가, SNS에서 스치듯 Giscus란 걸 보게 되었다. 살펴보니 Utterances와 굉장히 유사하지만 코멘트 뿐만 아니라 리액션을 따로 남길 수 있는 점이 끌렸다. 이름은 Git + Disqus(랑 비슷) + (GitHub) Discussion 을 적절히 합친 것 같다. 그래서 GitHub 저장소 하나를 씨드로 하고 여기에 Giscus 앱을 설치해서 GitHub의 Discussion 기능을 활용하여 리액션과 코멘트를 관리하는 것으로 보인다. 한글 지원도 잘 되는 것이 마음에 든다. Lazy loading도 지원해서 사이트 로딩이 무거워지지 않아서(=그런 것처럼 느껴져서) 좋다. 예전에 찍혔던 하트가 날아간 것은 조금 아쉽지만, 훨씬 더 눈에 잘 들어오는 리액션과 코멘트 박스가 생긴 것은 정말 마음에 든다. 거기다 내가 계정을 관리할 필요 없이 깃허브 계정만 있으면 모든 것을 할 수 있다니. 오픈소스의 위대함을 다시 한번 느낄 수 있었다. 이제 내가 글만 쓰면 된다&#8230;]]></summary></entry><entry><title type="html">Doom Emacs</title><link href="https://sangwoo-joh.github.io/doom-emacs" rel="alternate" type="text/html" title="Doom Emacs" /><published>2023-02-25T00:00:00+00:00</published><updated>2023-02-25T00:00:00+00:00</updated><id>https://sangwoo-joh.github.io/doom-emacs</id><content type="html" xml:base="https://sangwoo-joh.github.io/doom-emacs"><![CDATA[<p>오랜만의 이맥스 글이다. <a href="https://github.com/doomemacs/doomemacs">둠 이맥스</a>를 각잡고 쓰기 시작한지 이제 한달이 조금
  넘었는데, 이 좋은 걸 나만 알고 있기 아깝다는 생각에 글로 남겨본다.</p>
<h2>둠 이맥스로 넘어온 이유</h2>
<p>예전 글에서도 몇 번 얘기한 적이 있지만, 내 이맥스 설정은 부팅(?)이 느리다.
  이맥스를 쓰는 사람이 백만명이면 백만개의 이맥스 설정이 가능하기 때문에 모두가
  각자의 이맥스를 가지게 된다. 그래서 정확히 말하자면 <i>이맥스</i> 가 느린게 아니라 <i>내
  이맥스</i> 가 느렸다. 특히 이맥스를 <code>emacs &amp;</code> 로 처음 실행하고 GUI가 전부 로딩된 후
  입력이 가능하기 까지 굉장히 오랜 시간이 걸렸는데 (이 시간을 보통 startup time,
  launch time 등으로 부르는데 나는 부팅 시간이라고 하겠다), 심한 경우에는 3분
  가까이 걸리기도 했다. 수많은 패키지를 로딩하고 있는 이맥스를 보며 하염없이
  기다리기만 하는 것이다.</p>
<p>그래서 이맥스를 한번 실행하면 잘 안끄는 버릇이 생겼다. 이맥스를 OS라고도
  부르기도 할 만큼 거의 모든 작업을 이맥스 위에서 하니 이 자체는 꽤 괜찮은
  프랙티스라고 생각한다. 하지만 종종 재택근무를 할 때에는 윈도우에서 리눅스에
  원격으로 붙은 뒤에 작업을 해야 했는데, 이때는 어쩔 수 없이 이맥스를 새로 켜야
  했다. 그리고 그때마다 부팅 시간을 낭비하게 되었다.</p>
<p>그래서 작년 말에 대체 왜 <i>내</i> 이맥스는 부팅이 이렇게 느린건지 한번 토끼 굴을
  파보기로 했다. 일단 내 설정에서 <code>use-package</code> 로 사용 중인 패키지를 세어보니
  63개였다. 각 패키지마다 의존성이 있는 패키지까지 합치면 더 많을 거라 생각했고
  <code>eln-cache</code> 에서 컴파일된 패키지 수를 세어보니 과연 400개가 넘었다. 이맥스를 켜면
  상태창에 뭔가 잔뜩 로딩하는 메시지가 지나갔기 때문에, 패키지를 로딩하는 작업
  자체가 병목이라는 생각이 들었다. 사실 예전에 네이티브 컴파일 이맥스를 시도했던
  가장 큰 이유도, 거대한 리습 인터프리터라고 불리는 이맥스가 내 패키지 설정을
  로딩하는 속도 자체를 빠르게 해주지 않을까 하는 기대에서였다. 아무튼, 이맥스의
  패키지 로딩 속도와 관련한 키워드로 검색하다 보니 또 계시처럼 <a href="https://github.com/doomemacs/doomemacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly">이런 글</a>을 만나게
  되었고, 마침 너무나도 갈망하던 흥미로운 주제라서 그 자리에서 각잡고 정독하였다.</p>
<p>사실 다양한 이맥스 변종이 있다는 것은 예전부터 알고 있었다. 스페이스맥스라던가.
  둠 이맥스도 어렴풋이 들어는 봤었고, 그냥 또 이맥스에 예쁜 껍데기를 입힌 거라고
  생각했다. 하지만, 둠 이맥스 개발자가 정성스럽게 작성한 문서를 읽다보니 둠
  이맥스만의 철학에 크게 공감하게 되었고, 살짝 테스트만 해보고 &#8220;아 이거다&#8221; 싶은
  생각이 들자마자 일말의 망설임도 없이 내 모든 설정을 둠 이맥스로 옮기기로
  결심했다. 그 결과 지금은 <a href="https://github.com/sangwoo-joh/.doom.d">마이그레이션 완료</a>한지 한달이 조금 넘었고 아주
  만족스럽게 사용하고 있다.</p>
<h2>내가 이해한 둠 이맥스의 철학</h2>
<p>둠 이맥스의 철학은 깃허브에서 직접 <a href="https://github.com/doomemacs/doomemacs/blob/master/docs/faq.org">문서</a>를 읽어보는 것이 가장 좋다. 내가 이해한
  내용과 그에 대한 나의 멘탈 모델을 정리하자면 다음과 같다.</p>
<p>둠 이맥스는:</p>
<ol>
  <li><b>모던 패키지 매니저</b> 이다. 이맥스의 기본 패키지 로더를 최적화하고 적극적인
    Lazy Loading을 통해 빠른 부팅 속도를 제공한다. 그리고 다양한 매크로를 통해
    패키지 설정을 편리하게 해준다.
    <a href="https://github.com/doomemacs/doomemacs/blob/develop/docs/faq.org#why-such-a-complicated-package-management-system">둠
    패키지 관리 시스템의 목표</a> 문서에 좀더 자세히 나와있다.</li>
  <li>이맥스 패키지 생태계의 메이저를 모아둔 <b>큐레이터</b> 이다. 둠에서는 그 목표 중
    하나인 <b>Reproducibility</b> 를 달성하기 위해서 많이 쓰이는 패키지의 커밋을
    고정시키고 이를 <i>모듈</i> 이라는 이름으로 관리하고 있다. 덕분에 나도 잘 모르던
    메이저 패키지를 많이 알게 되었고 덕분에 지금 내 이맥스는 엄청나게 진화했다.</li>
  <li><i>최첨단 이맥스 프레임워크</i> 이다. 이는 두 가지를 내포하고 있는데: <b>최첨단</b> 이라는
    뜻은 <i>개발 중</i> 이라는 뜻이다(&#8230;) 실제로 그렇기도 하고. 입맛에 맞게
    커스터마이징 하다보면 종종 이슈에 맞닥뜨리게 되고 그때마다 직접 해결해야
    한다. 실제로 마이그레이션 도중 몇 번 이맥스가 먹통이 되어서 캐시를 날리고
    다시 설치하기도 했다. 그래도 (숙련된 이맥스 사용자에게는) 트러블슈팅이
    어렵지 않은 편인 것 같아 다행이다. 그리고 <b>프레임워크</b> 라서, <code>.emacs.d</code> 의
    관리는 온전히 둠에게 맡기고, 우리는 우리에게 주어진 새로운 땅인 <code>.doom.d</code> 에서
    <i>둠 이맥스를 위한 설정</i> 을 해야 한다. 이는 그동안 <code>.emacs.d</code> 에서 많은 것을 할
    수 있었던 자유를 빼앗기는 기분도 들지만, 또 한편으로 많은 것을 대신해주고
    기존의 너무나도 자유롭던 <code>.emacs.d</code> 설정에서 벗어나게 해줘서 마음이 홀가분
    하기도 하다.</li>
</ol>
<h2>아쉬운 점</h2>
<p>세상에 완벽한 물건은 없다. 아쉬운 점을 꼽자면 다음과 같다.</p>
<ol>
  <li><code>eyebrowse</code> 의 대용품으로 <code>persp-mode</code> 를 내장하고 있는데 이게 좀 아쉽다. 예를
    들면 키 바인딩은 0번 작업 공간인데 UI 넘버링은 <code>#1</code> 로 되어 있다거나, 반드시
    작업 공간을 생성해야 넘어간다거나 하는 등 소소한 부분에서 <code>eyebrowse</code> 보다
    애매하게 불편하다. 그래서 <code>eyebrowse</code> 를 직접 써봤는데 아쉽게도 <code>.emacs.d</code> 를
    둠이 관리하다 보니 이전 작업 공간이 제대로 복구가 안된다. 둠이 관리하는
    경로를 가져와서 설정하면 잘 동작하긴 하겠지만, 그렇다고 또 그렇게까지 할
    정도로 기본 작업 공간이 크게 불편하진 않아서 그냥저냥 쓰고 있다. 그리고
    무엇보다
    <a href="https://github.com/doomemacs/doomemacs/issues/5255#issuecomment-877835286">원작자의
    계획</a>도 추후에는 <code>eyebrowse</code> 로 넘어가는 것이라고 하니 기다려 보려고 한다.</li>
  <li>아무래도 오픈소스 프로젝트이다 보니 개발 진행 사항이나 이슈 처리 속도가
    아쉬운 것은 어쩔 수 없다. 이 글을 쓰는 시점에서도 이미 이슈가 500개 넘게
    쌓여 있다. 오히려 그동안 3500개 가까이를 (거의) 혼자서 소화한 게 신기할
    정도이다. 컨트리뷰터가 많긴 한데 사실상 원작자인 <a href="https://github.com/hlissner">Henrik Lissner</a>가 거의 다
    혼자 개발 중이다. 그래서 패키지마자 메인테이너를 구한다는 짤막한 글이 있다
    (&#8230;). 나도 언젠가 기여해보고 싶지만 이게 원작자가 2014년부터 혼자서
    깎아오던 방망이라서 거대한 흐름을 파악하는데는 시간이 좀더 걸릴 것 같다.
    게다가 엄청 급한 이슈가 아니면 리뷰에도 시간이 꽤 걸리기 때문에.. 아직 열린
    PR이 88개나 있다&#8230;</li>
</ol>
<h2>좋은 점</h2>
<p>사실 위의 두 가지 아쉬운 점 빼고는 모든 것이 만족스럽다. 왜 진작 둠 이맥스를
  안썼을까 하는 생각이 들 정도로.</p>
<p>일단 이맥스 부팅 속도가 너무너무 만족스럽다. 과장 좀 보태서 아무런 설정없는
  바닐라 이맥스를 켜는 것과 다름없는 속도다. &#8220;프로그램 켜는 속도가 대체 뭐가
  중요해?&#8221; 라고 생각할 수도 있겠지만, 앞에서 말했듯 나는 이맥스를 다양한 환경에서
  사용하고 있어서 이맥스가 켜지는 속도는 생산성에 큰 영향을 미치기 때문에 이
  최적화는 너무 원하던 것이다. 지금은 그냥 켜면 곧바로 뜨고, 마지막 세션 로딩하면
  필요한 패키지만 로딩이 되고, 작업하고 싶은 파일을 열면 또 거기에 맞는 패키지만
  로딩이 되어서 속도가 엄청나게 쾌적해졌다.</p>
<p>몰랐던 패키지들도 많이 알게되었다. 예를 들면 예전에는 <code>OCaml</code> 개발에 필요한
  기능을 직접 개발해서 모듈로 관리하고 있는데, <code>merlin-company</code> 라던가 이런
  패키지들이 있는지 몰랐다. 나는 마음 편히 그걸 가져다 쓰면 된다. 심지어 원래 내
  세팅이랑 거의 유사해서 적응조차 필요 없었다&#8230; 역시 이맥스 유저들은 다 비슷한가
  보다. 거기다 각 언어 별 패키지 중 &#8220;가장 메이저(= 기능이 많고 안정성이 높은)&#8221;
  들을 모아두다 보니 예전보다 훨씬 쾌적하다. 예를 들어 파이썬의 경우 원래는 <code>elpy</code>
  를 쓰고 있었는데, 둠이 채택한 <code>anaconda-mode</code> 를 (아나콘다 없이) 쓰는 게 훨씬
  쾌적할 줄은 정말 몰랐다.</p>
<p>무엇보다 둠 이맥스의 코드를 보면서 이맥스 리습 코드를 잘 짜는 방법을 배울 수
  있었다. 항상 <code>lexical-binding</code> 을 한다거나, 네이밍으로 네임스페이스를
  관리한다거나.. 이런 프랙티스를 코드를 읽으면서 엿볼 수 있어서 좋았다.
  마이그레이션할 때 요긴하게 잘 써먹었다.</p>
<p>그리고 둠이 제공하는 <code>.doom.d</code> 의 구조를 통해서 에디터의 설정 파일을 어떻게
  관리할지에 대해서도 멘탈 모델을 좀더 단단하게 굳힐 수 있었다. <code>.doom.d</code> 는
  기본적으로 둠 모듈(패키지)를 구성하는 <code>init.el</code> 파일과 써드파티 패키지를 기술하는
  <code>packages.el</code> 파일, 그리고 그 외 모든 모듈에 대한 설정을 기술하는 <code>config.el</code>
  파일로 구성된다. 이때까지 나는 기능 단위로 리습 모듈을 작성했었는데, 예를 들어
  <code>OCaml</code> 과 관련된 모든 패키지/설정/단축키/함수를 <code>ocaml.el</code> 에 작성하는 식이다.
  그런데 이렇게하면 기능이 추가될 때마다 계속 파일이 늘어나게 되고, 또 기능마다
  공통적인 의존성이 생기면 기능 단위가 아닌 공통 함수를 담은 패키지를 만들게 되는
  등의 부차적인 귀찮음이 있었다. 하지만 이제 둠의 방식을 따르게 되면서 더 이상
  이런 것을 고민하지 않게 되었다. 공식 모듈은 <code>init.el</code> 에, 추가적인 모듈은
  <code>packages.el</code> 에, 나머지는 모두 <code>config.el</code> 에. 기존에 쓰던 패키지 대부분은 이미
  공식 모듈의 부분집합이었고, 기능 단위로 작성했던 커스텀 함수들을 모두 <code>config.el</code>
  에 때려박고 보니 600 라인 정도의 설정이 탄생하였다. 이 중 200 라인 정도는
  패키지 별로 자주 사용하는 키 바인딩에 대한 주석이라서, 실제 함수는 400 라인
  정도 밖에 안된다. 마음에 든다.</p>
<p>솔직히 예전에는 주변에서 이맥스에 관심이 있거나 혹은 이맥스를 시작하려고 하는
  사람이 있다면 여러 가지 이유로 말릴 생각이 더 컸다. 에디터를 대하는 멘탈 모델이
  일반적인 에디터와 조금 다른 탓에 흉흉한(?) 소문이 많아서 이기도 했지만, 다른
  에디터에는 있는 화려한 기능을 &#8220;어떻게&#8221; 잘 찾아서 적용할 수 있는지 설명하는 것이
  너무 어려웠기 때문이다. 원하는 기능마다 &#8220;공식&#8221;이라고 부를 만한 게 없기도 하고,
  패키지도 <code>GNU</code> 랑 <code>non-gnu</code> 로 파편화되어 있어서 딱 &#8220;이거 쓰세요&#8221;라고 하기가
  어려웠다. 하지만 둠 이맥스를 만난 지금은 <code>help-with-tutorial</code> 로 기본적인 컨셉과
  키 바인딩만 익히게 한 다음 곧바로 둠 이맥스를 설치하게 알려주면 좋을 것 같다.
  그만큼 둠에 포함된 모듈들은 여타 메이저 에디터들과 비교해도 손색이 없고 모양도
  모던하다.</p>
<p>물론 요즘 누가 이맥스를 쓰냐고 물어보면 사실 할 말이 없다. 🥲</p>]]></content><author><name>sangwoo-joh</name></author><category term="dev" /><summary type="html"><![CDATA[오랜만의 이맥스 글이다. 둠 이맥스를 각잡고 쓰기 시작한지 이제 한달이 조금 넘었는데, 이 좋은 걸 나만 알고 있기 아깝다는 생각에 글로 남겨본다. 둠 이맥스로 넘어온 이유 예전 글에서도 몇 번 얘기한 적이 있지만, 내 이맥스 설정은 부팅(?)이 느리다. 이맥스를 쓰는 사람이 백만명이면 백만개의 이맥스 설정이 가능하기 때문에 모두가 각자의 이맥스를 가지게 된다. 그래서 정확히 말하자면 이맥스 가 느린게 아니라 내 이맥스 가 느렸다. 특히 이맥스를 emacs &amp; 로 처음 실행하고 GUI가 전부 로딩된 후 입력이 가능하기 까지 굉장히 오랜 시간이 걸렸는데 (이 시간을 보통 startup time, launch time 등으로 부르는데 나는 부팅 시간이라고 하겠다), 심한 경우에는 3분 가까이 걸리기도 했다. 수많은 패키지를 로딩하고 있는 이맥스를 보며 하염없이 기다리기만 하는 것이다. 그래서 이맥스를 한번 실행하면 잘 안끄는 버릇이 생겼다. 이맥스를 OS라고도 부르기도 할 만큼 거의 모든 작업을 이맥스 위에서 하니 이 자체는 꽤 괜찮은 프랙티스라고 생각한다. 하지만 종종 재택근무를 할 때에는 윈도우에서 리눅스에 원격으로 붙은 뒤에 작업을 해야 했는데, 이때는 어쩔 수 없이 이맥스를 새로 켜야 했다. 그리고 그때마다 부팅 시간을 낭비하게 되었다. 그래서 작년 말에 대체 왜 내 이맥스는 부팅이 이렇게 느린건지 한번 토끼 굴을 파보기로 했다. 일단 내 설정에서 use-package 로 사용 중인 패키지를 세어보니 63개였다. 각 패키지마다 의존성이 있는 패키지까지 합치면 더 많을 거라 생각했고 eln-cache 에서 컴파일된 패키지 수를 세어보니 과연 400개가 넘었다. 이맥스를 켜면 상태창에 뭔가 잔뜩 로딩하는 메시지가 지나갔기 때문에, 패키지를 로딩하는 작업 자체가 병목이라는 생각이 들었다. 사실 예전에 네이티브 컴파일 이맥스를 시도했던 가장 큰 이유도, 거대한 리습 인터프리터라고 불리는 이맥스가 내 패키지 설정을 로딩하는 속도 자체를 빠르게 해주지 않을까 하는 기대에서였다. 아무튼, 이맥스의 패키지 로딩 속도와 관련한 키워드로 검색하다 보니 또 계시처럼 이런 글을 만나게 되었고, 마침 너무나도 갈망하던 흥미로운 주제라서 그 자리에서 각잡고 정독하였다. 사실 다양한 이맥스 변종이 있다는 것은 예전부터 알고 있었다. 스페이스맥스라던가. 둠 이맥스도 어렴풋이 들어는 봤었고, 그냥 또 이맥스에 예쁜 껍데기를 입힌 거라고 생각했다. 하지만, 둠 이맥스 개발자가 정성스럽게 작성한 문서를 읽다보니 둠 이맥스만의 철학에 크게 공감하게 되었고, 살짝 테스트만 해보고 &#8220;아 이거다&#8221; 싶은 생각이 들자마자 일말의 망설임도 없이 내 모든 설정을 둠 이맥스로 옮기기로 결심했다. 그 결과 지금은 마이그레이션 완료한지 한달이 조금 넘었고 아주 만족스럽게 사용하고 있다. 내가 이해한 둠 이맥스의 철학 둠 이맥스의 철학은 깃허브에서 직접 문서를 읽어보는 것이 가장 좋다. 내가 이해한 내용과 그에 대한 나의 멘탈 모델을 정리하자면 다음과 같다. 둠 이맥스는: 모던 패키지 매니저 이다. 이맥스의 기본 패키지 로더를 최적화하고 적극적인 Lazy Loading을 통해 빠른 부팅 속도를 제공한다. 그리고 다양한 매크로를 통해 패키지 설정을 편리하게 해준다. 둠 패키지 관리 시스템의 목표 문서에 좀더 자세히 나와있다. 이맥스 패키지 생태계의 메이저를 모아둔 큐레이터 이다. 둠에서는 그 목표 중 하나인 Reproducibility 를 달성하기 위해서 많이 쓰이는 패키지의 커밋을 고정시키고 이를 모듈 이라는 이름으로 관리하고 있다. 덕분에 나도 잘 모르던 메이저 패키지를 많이 알게 되었고 덕분에 지금 내 이맥스는 엄청나게 진화했다. 최첨단 이맥스 프레임워크 이다. 이는 두 가지를 내포하고 있는데: 최첨단 이라는 뜻은 개발 중 이라는 뜻이다(&#8230;) 실제로 그렇기도 하고. 입맛에 맞게 커스터마이징 하다보면 종종 이슈에 맞닥뜨리게 되고 그때마다 직접 해결해야 한다. 실제로 마이그레이션 도중 몇 번 이맥스가 먹통이 되어서 캐시를 날리고 다시 설치하기도 했다. 그래도 (숙련된 이맥스 사용자에게는) 트러블슈팅이 어렵지 않은 편인 것 같아 다행이다. 그리고 프레임워크 라서, .emacs.d 의 관리는 온전히 둠에게 맡기고, 우리는 우리에게 주어진 새로운 땅인 .doom.d 에서 둠 이맥스를 위한 설정 을 해야 한다. 이는 그동안 .emacs.d 에서 많은 것을 할 수 있었던 자유를 빼앗기는 기분도 들지만, 또 한편으로 많은 것을 대신해주고 기존의 너무나도 자유롭던 .emacs.d 설정에서 벗어나게 해줘서 마음이 홀가분 하기도 하다. 아쉬운 점 세상에 완벽한 물건은 없다. 아쉬운 점을 꼽자면 다음과 같다. eyebrowse 의 대용품으로 persp-mode 를 내장하고 있는데 이게 좀 아쉽다. 예를 들면 키 바인딩은 0번 작업 공간인데 UI 넘버링은 #1 로 되어 있다거나, 반드시 작업 공간을 생성해야 넘어간다거나 하는 등 소소한 부분에서 eyebrowse 보다 애매하게 불편하다. 그래서 eyebrowse 를 직접 써봤는데 아쉽게도 .emacs.d 를 둠이 관리하다 보니 이전 작업 공간이 제대로 복구가 안된다. 둠이 관리하는 경로를 가져와서 설정하면 잘 동작하긴 하겠지만, 그렇다고 또 그렇게까지 할 정도로 기본 작업 공간이 크게 불편하진 않아서 그냥저냥 쓰고 있다. 그리고 무엇보다 원작자의 계획도 추후에는 eyebrowse 로 넘어가는 것이라고 하니 기다려 보려고 한다. 아무래도 오픈소스 프로젝트이다 보니 개발 진행 사항이나 이슈 처리 속도가 아쉬운 것은 어쩔 수 없다. 이 글을 쓰는 시점에서도 이미 이슈가 500개 넘게 쌓여 있다. 오히려 그동안 3500개 가까이를 (거의) 혼자서 소화한 게 신기할 정도이다. 컨트리뷰터가 많긴 한데 사실상 원작자인 Henrik Lissner가 거의 다 혼자 개발 중이다. 그래서 패키지마자 메인테이너를 구한다는 짤막한 글이 있다 (&#8230;). 나도 언젠가 기여해보고 싶지만 이게 원작자가 2014년부터 혼자서 깎아오던 방망이라서 거대한 흐름을 파악하는데는 시간이 좀더 걸릴 것 같다. 게다가 엄청 급한 이슈가 아니면 리뷰에도 시간이 꽤 걸리기 때문에.. 아직 열린 PR이 88개나 있다&#8230; 좋은 점 사실 위의 두 가지 아쉬운 점 빼고는 모든 것이 만족스럽다. 왜 진작 둠 이맥스를 안썼을까 하는 생각이 들 정도로. 일단 이맥스 부팅 속도가 너무너무 만족스럽다. 과장 좀 보태서 아무런 설정없는 바닐라 이맥스를 켜는 것과 다름없는 속도다. &#8220;프로그램 켜는 속도가 대체 뭐가 중요해?&#8221; 라고 생각할 수도 있겠지만, 앞에서 말했듯 나는 이맥스를 다양한 환경에서 사용하고 있어서 이맥스가 켜지는 속도는 생산성에 큰 영향을 미치기 때문에 이 최적화는 너무 원하던 것이다. 지금은 그냥 켜면 곧바로 뜨고, 마지막 세션 로딩하면 필요한 패키지만 로딩이 되고, 작업하고 싶은 파일을 열면 또 거기에 맞는 패키지만 로딩이 되어서 속도가 엄청나게 쾌적해졌다. 몰랐던 패키지들도 많이 알게되었다. 예를 들면 예전에는 OCaml 개발에 필요한 기능을 직접 개발해서 모듈로 관리하고 있는데, merlin-company 라던가 이런 패키지들이 있는지 몰랐다. 나는 마음 편히 그걸 가져다 쓰면 된다. 심지어 원래 내 세팅이랑 거의 유사해서 적응조차 필요 없었다&#8230; 역시 이맥스 유저들은 다 비슷한가 보다. 거기다 각 언어 별 패키지 중 &#8220;가장 메이저(= 기능이 많고 안정성이 높은)&#8221; 들을 모아두다 보니 예전보다 훨씬 쾌적하다. 예를 들어 파이썬의 경우 원래는 elpy 를 쓰고 있었는데, 둠이 채택한 anaconda-mode 를 (아나콘다 없이) 쓰는 게 훨씬 쾌적할 줄은 정말 몰랐다. 무엇보다 둠 이맥스의 코드를 보면서 이맥스 리습 코드를 잘 짜는 방법을 배울 수 있었다. 항상 lexical-binding 을 한다거나, 네이밍으로 네임스페이스를 관리한다거나.. 이런 프랙티스를 코드를 읽으면서 엿볼 수 있어서 좋았다. 마이그레이션할 때 요긴하게 잘 써먹었다. 그리고 둠이 제공하는 .doom.d 의 구조를 통해서 에디터의 설정 파일을 어떻게 관리할지에 대해서도 멘탈 모델을 좀더 단단하게 굳힐 수 있었다. .doom.d 는 기본적으로 둠 모듈(패키지)를 구성하는 init.el 파일과 써드파티 패키지를 기술하는 packages.el 파일, 그리고 그 외 모든 모듈에 대한 설정을 기술하는 config.el 파일로 구성된다. 이때까지 나는 기능 단위로 리습 모듈을 작성했었는데, 예를 들어 OCaml 과 관련된 모든 패키지/설정/단축키/함수를 ocaml.el 에 작성하는 식이다. 그런데 이렇게하면 기능이 추가될 때마다 계속 파일이 늘어나게 되고, 또 기능마다 공통적인 의존성이 생기면 기능 단위가 아닌 공통 함수를 담은 패키지를 만들게 되는 등의 부차적인 귀찮음이 있었다. 하지만 이제 둠의 방식을 따르게 되면서 더 이상 이런 것을 고민하지 않게 되었다. 공식 모듈은 init.el 에, 추가적인 모듈은 packages.el 에, 나머지는 모두 config.el 에. 기존에 쓰던 패키지 대부분은 이미 공식 모듈의 부분집합이었고, 기능 단위로 작성했던 커스텀 함수들을 모두 config.el 에 때려박고 보니 600 라인 정도의 설정이 탄생하였다. 이 중 200 라인 정도는 패키지 별로 자주 사용하는 키 바인딩에 대한 주석이라서, 실제 함수는 400 라인 정도 밖에 안된다. 마음에 든다. 솔직히 예전에는 주변에서 이맥스에 관심이 있거나 혹은 이맥스를 시작하려고 하는 사람이 있다면 여러 가지 이유로 말릴 생각이 더 컸다. 에디터를 대하는 멘탈 모델이 일반적인 에디터와 조금 다른 탓에 흉흉한(?) 소문이 많아서 이기도 했지만, 다른 에디터에는 있는 화려한 기능을 &#8220;어떻게&#8221; 잘 찾아서 적용할 수 있는지 설명하는 것이 너무 어려웠기 때문이다. 원하는 기능마다 &#8220;공식&#8221;이라고 부를 만한 게 없기도 하고, 패키지도 GNU 랑 non-gnu 로 파편화되어 있어서 딱 &#8220;이거 쓰세요&#8221;라고 하기가 어려웠다. 하지만 둠 이맥스를 만난 지금은 help-with-tutorial 로 기본적인 컨셉과 키 바인딩만 익히게 한 다음 곧바로 둠 이맥스를 설치하게 알려주면 좋을 것 같다. 그만큼 둠에 포함된 모듈들은 여타 메이저 에디터들과 비교해도 손색이 없고 모양도 모던하다. 물론 요즘 누가 이맥스를 쓰냐고 물어보면 사실 할 말이 없다. 🥲]]></summary></entry><entry><title type="html">블로그 새 단장</title><link href="https://sangwoo-joh.github.io/facelift-blog" rel="alternate" type="text/html" title="블로그 새 단장" /><published>2022-12-07T00:00:00+00:00</published><updated>2022-12-07T00:00:00+00:00</updated><id>https://sangwoo-joh.github.io/facelift-blog</id><content type="html" xml:base="https://sangwoo-joh.github.io/facelift-blog"><![CDATA[<p>스스로 본업은 백엔드라고 받아들이고 있는데, 은근히 회사에서
 프론트엔드를 만져야하는 일이 꽤 있다. 다행히(?) 대중에게 공개할
 물건은 아니고 사내에서만 쓰는 도구라서 여태까지 어떻게든 뚝딱거려
 왔는데, 이번에 좋은 기회로 프론트엔드 관련 강의를 듣게 되었다. 덕분에
 웹의 기초가 되는 HTML, CSS와 좀더 친해진 기분이 들었다.</p>

<p>CSS의 온갖 요상하고 때때로 암묵적이기까지 한 규칙들 (e.g., 가상
 클래스라던지, 폰트가 왜 여러개 있는지, <code class="language-plaintext highlighter-rouge">margin</code>에 속성 여러개
 때려박으면 어떻게 되는지, 등등…) 때문에 공부하면서도 “이걸
 이렇게까지 쓸 일이 있을까?” 싶은 생각이 들긴 했지만… 어쨌든 어딘가
 필요하기 때문에 있는 기능이니 너무 두려워하지 않고 나중에 만나더라도
 뇌에 힘줘서 이해하면 되겠지, 정도로 받아들이게 되었다.</p>

<p>그런데 조금이나마 프론트엔드, 그 중에서도 CSS를 이해하고 나니 손이
 근질거려서 참을 수가 없더라. 그래서 미니멀을 지향하는 이 블로그
 홈페이지를 새롭게 단장해보았다. 나의 미학(…)을 표현한 결과가 바로
 이 모습이다. 아주 마음에 든다. 기분 탓인지 글이 좀더 읽기 쉬워진 것
 같기도 하다. 덕분에 블로그 글을 한번 정주행할 수 있었다.</p>

<p>이제 HTML, CSS, JavaScript 삼신기를 찍먹해보았으니 해보고 싶은 남은
 일들은 아래와 같다.</p>
<ul>
  <li>Emacs까지 가공한 무언가를 만들기. 지금 떠오르는 것은 저장하기
이벤트를 후킹해서 포스트 메타데이터에 마지막 수정 날짜를 박고, 이걸
이용해서 지금의 <strong>[new!]</strong> 레이블과 비슷한 <strong>[updated!]</strong> 레이블을
달아보는 것이다.</li>
  <li>리액트로 취미 코딩하기. 아이디어는 꽤 쌓여있는데 이 중에서 어떤 걸
털어볼지 고민이다. 최종적으로는 ReScript까지 가보고 싶다.</li>
</ul>

<p>리액트 취미 코딩은 좀더 긴 호흡으로 내년 내내 진행해볼
 생각이다. 레이블은 아마 근 시일 내에 이 글에 <strong>[updated!]</strong> 레이블이
 붙지 않을까 하는 마음가짐으로 미래의 나에게 떠넘긴다.</p>

<hr />

<p>쉬엄쉬엄 하다보니 어느새 완성해버렸다. <strong>[updated!]</strong> 레이블은
 <a href="https://github.com/sangwoo-joh/sangwoo-joh.github.io/commit/87d15788a91c8a51cca8896d18d80793f191a822"><strong>[new!]</strong> 레이블을 붙였을
 때와</a>
 <a href="https://github.com/sangwoo-joh/sangwoo-joh.github.io/commit/51f1f1a7721794b4768ddf09ebff289f7f751769">유사하게</a>
 구현하였다. 마지막까지 <code class="language-plaintext highlighter-rouge">updated</code>, <code class="language-plaintext highlighter-rouge">revised</code>, <code class="language-plaintext highlighter-rouge">changed</code> 등의 표현
 중에서 뭐가 제일 자연스러운지 고민했는데 네이티브가 아니니 그냥 처음
 떠오른 걸로 가기로 했다.</p>

<p><a href="https://github.com/sangwoo-joh/.emacs.d/commit/443a28e00ca95df5a43576c8aa1c32ab3be5b36f">타임스탬프
 훅</a>을
 구현하는 것도 재밌었다. 이제 Elisp으로 개인적인 장난감을 만드는 데 꽤
 익숙해진 것 같다. 설명하자면 먼저 <code class="language-plaintext highlighter-rouge">---</code>로 시작하는 YAML 섹션을 찾은
 다음 미리 약속한 속성 키 값인 <code class="language-plaintext highlighter-rouge">last_update</code>가 있는지 살펴본다. 없으면
 새로 넣고, 있으면 있는 위치에서 이전 값을 날려버린다. 그 후 현재
 타임스탬프를 그자리에 박는다. 구현은 이게 끝이다. 이제 이걸
 <code class="language-plaintext highlighter-rouge">'before-save-hook</code>에 등록해서 저장할 때마다 이 함수가 실행되게 하면
 된다. 그렇지만 모든 모드에서 타임스탬프를 찍는 것은 의미가 없으니,
 마크다운을 수정할 때에만 훅을 걸고 싶다. 찾아보니 <a href="https://emacs.stackexchange.com/a/5777">로컬
 훅</a>을 거는 멋진 방법이 있길래
 적용했다. 그리고 이리저리 테스트해보니, 이 훅이 동작하지 않았으면
 하는 마크다운 파일(예: 처음 발행하는 문서)도 있었다. 그래서 아예 훅을
 거는 함수와 빼는 함수를 <code class="language-plaintext highlighter-rouge">(interactive)</code>로 만들어서 필요할 때
 호출하기로 했다. 로컬 훅을 걸 때도 이 함수를 재사용했다.</p>

<p>그 결과 지금 보이는 것처럼, 이제 발행된 이후에 수정한 글에는
 <strong>[updated!]</strong> 태그가 자동으로 붙는다! 오랜만의 재미난 취미
 코딩이었다.</p>]]></content><author><name>sangwoo-joh</name></author><category term="dev" /><summary type="html"><![CDATA[스스로 본업은 백엔드라고 받아들이고 있는데, 은근히 회사에서 프론트엔드를 만져야하는 일이 꽤 있다. 다행히(?) 대중에게 공개할 물건은 아니고 사내에서만 쓰는 도구라서 여태까지 어떻게든 뚝딱거려 왔는데, 이번에 좋은 기회로 프론트엔드 관련 강의를 듣게 되었다. 덕분에 웹의 기초가 되는 HTML, CSS와 좀더 친해진 기분이 들었다.]]></summary></entry><entry><title type="html">OCaml로 PS 하기 -7-</title><link href="https://sangwoo-joh.github.io/ocaml-ps-monadic-parser-combinator" rel="alternate" type="text/html" title="OCaml로 PS 하기 -7-" /><published>2022-10-07T00:00:00+00:00</published><updated>2022-10-07T00:00:00+00:00</updated><id>https://sangwoo-joh.github.io/ocaml-ps-monadic-parser-combinator</id><content type="html" xml:base="https://sangwoo-joh.github.io/ocaml-ps-monadic-parser-combinator"><![CDATA[<p>풀고 싶었던 문제를 드디어 풀었다.</p>

<p>19년도 말 즈음부터 OCaml로 PS를 시작했는데, 여기에는 몇 가지 계기가
 있었다. OCaml로 밥벌이를 할 수 없는 아쉬움이 가장 큰 이유였지만,
 “백준에서 OCaml로 PS 하기”에 결정적인 역할을 한 것은 kipa00님의
 <a href="https://www.acmicpc.net/blog/view/66">OCaml로 문제 풀이하기</a>라는
 글이었다.  그때부터 백준에서 PS를 시작해봤고, 또 이 문제는 언젠가 꼭
 풀고 싶다는 생각을 해왔다. 다만 같은 방법으로 풀면 재미없으니까 다른
 방법으로 풀어봐야지 라는 생각만 어렴풋이 가지고 있었다.  하지만
 정말로 이 문제를 풀기까지의 과정은 쉽지 않았다. 근본적으로는 내가 PS
 자체에 익숙하지 않은 탓이 컸다. 애초에 PS를 제대로 해본 적이 없으니
 당연한 일이었다. 데이터 구조와 알고리즘을 그냥 “알고” 있는 것과,
 온라인 저지 사이트에서 문제를 이해하고 풀이에 필요한 것들을 코드로
 모델링하고 시간 및 메모리 제한에 맞는 알고리즘을 구현해서 평가 테스트
 셋을 통과하는 것은 꽤 간극이 컸다. PS는 정말로 훈련이 필요한
 일이었다.</p>

<p>변명을 하자면 육아와 건강 문제로 많은 시간을 쏟진 못했지만, 틈틈이
 PS를 해오고 있었다. 그러다가 정말 우연히도 유튜브 추천 영상에
 <a href="https://www.twitch.tv/tsoding/about">Tsoding</a>이라는 트위치
 프로그래머 스트리머의 <a href="https://www.youtube.com/watch?v=Y5IIXUBXvLs">(의존성 없이) OCaml로 빠른 파서 컴비네이터
 라이브러리 밑바닥부터
 만들기</a>가 떴는데, 이건
 거의 계시에 가까웠고 홀린듯 볼 수 밖에 없었다. 대략 4시간 쯤 되는
 영상인데 보는 내내 힐링이었다… 이맥스로 코딩하는 모습도
 구경하고… 흠흠 아무튼 이 영상 덕분에 <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi0s7nUqrb6AhUkyYsBHUOaD-AQFnoECA0QAQ&amp;url=https%3A%2F%2Fwww.cs.nott.ac.uk%2F~pszgmh%2Fmonparsing.pdf&amp;usg=AOvVaw3LtR393c7YLbVqqhMb24Ty">Monadic Parser
 Combinators</a>라는
 서적과 이 친구가 만든 <a href="https://github.com/tsoding/parcoom">Parcoom</a>을
 알게 되었고, 여기에 원래 살펴보려 했던
 <a href="https://github.com/inhabitedtype/angstrom/">Angstrom</a>의 코드 등
 다양한 파서 컴비네이터 자료에 이틀 정도 푹 빠져서 지냈다. 그리고
 드디어 이 문제를 접한지 대략 3년 정도 만에 풀게 되었다.</p>

<h2 id="2769-논리식-비교"><a href="https://www.acmicpc.net/problem/2769">2769: 논리식 비교</a></h2>

<p>문제는 두 논리식이 주어졌을 때 같은지 아닌지를 판별하는
 것이다. 논리식은 변수 <code class="language-plaintext highlighter-rouge">a-z</code>, 이항 연산자 <code class="language-plaintext highlighter-rouge">|</code>, <code class="language-plaintext highlighter-rouge">&amp;</code>, <code class="language-plaintext highlighter-rouge">^</code>, 단항 연산자
 <code class="language-plaintext highlighter-rouge">~</code>, 괄호 <code class="language-plaintext highlighter-rouge">()</code>, 공백으로 이루어져 있고 변수는 최대 10개, 연산자는
 최대 100개이다. 연산자는 <a href="https://en.cppreference.com/w/c/language/operator_precedence">C의 연산자
 우선순위</a>를
 따른다. 두 논리식을 구분하는 것도 구현해야 한다.</p>

<h3 id="표현식-평가하기-evaluation">표현식 평가하기 (Evaluation)</h3>

<p>일단은 파서를 뺀 나머지 부분, 주어진 표현식 두 개가 같은지 판별하는
 것부터 구현해보자. 문제의 조건에 따라 변수가 최대 10개라서 가능한
 진리값 조합의 수가 \(2 ^ {10} = 1024\)로 작기 때문에, 이 가능한
 모든 진리값의 조합을 일일이 대입해서 두 식을 평가한 다음 같은지
 확인하면 된다. (문제 설명의 정규화는 반쯤은 낚시다…)</p>

<p>그런데 변수를 입력 그대로 <code class="language-plaintext highlighter-rouge">a-z</code> 값으로 가지고 있으면 변수에 진리값을
 대입하기가 까다롭다. 변수명이 <code class="language-plaintext highlighter-rouge">a</code>부터 나타난다는 보장도 없다. 따라서
 일종의 알파 변환이 필요하다. 변수가 등장한 순서대로 넘버링을 해서
 정수 아이디를 변수에 매달아 두면 좋을 것 같다. 그간 PS 겉핥기를 한
 덕분에 여러 조건의 조합을 표현할 때에는 비트 연산을 활용하면 좋다는
 것을 어렴풋이 알고 있어서 나중에 써먹기도 좋겠다. 알파 변환은 파서가
 담당해주기로 하고, 우리의 변수는 정수만을 담도록 하자.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">expr</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="nc">And</span> <span class="k">of</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>
  <span class="o">|</span> <span class="nc">Or</span>  <span class="k">of</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>
  <span class="o">|</span> <span class="nc">Xor</span> <span class="k">of</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>
  <span class="o">|</span> <span class="nc">Neg</span> <span class="k">of</span> <span class="n">expr</span>
</code></pre></div></div>

<p>변수에 진리값을 대입해주는 함수 <code class="language-plaintext highlighter-rouge">f</code>를 받아서 표현식을 참/거짓으로
 평가하는 함수 <code class="language-plaintext highlighter-rouge">eval</code>은 다음과 같다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">eval</span> <span class="o">~</span><span class="n">f</span> <span class="n">exp</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">aux</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Var</span> <span class="n">id</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">id</span>
    <span class="o">|</span> <span class="nc">Or</span> <span class="p">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">aux</span> <span class="n">e1</span> <span class="o">||</span> <span class="n">aux</span> <span class="n">e2</span>
    <span class="o">|</span> <span class="nc">And</span> <span class="p">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">aux</span> <span class="n">e1</span> <span class="o">&amp;&amp;</span> <span class="n">aux</span> <span class="n">e2</span>
    <span class="o">|</span> <span class="nc">Xor</span> <span class="p">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">aux</span> <span class="n">e1</span> <span class="o">&lt;&gt;</span> <span class="n">aux</span> <span class="n">e2</span>
    <span class="o">|</span> <span class="nc">Neg</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="n">aux</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">in</span>
  <span class="n">aux</span> <span class="n">exp</span>
</code></pre></div></div>

<p>변수에 진리값을 대입해주는 함수 <code class="language-plaintext highlighter-rouge">f</code>를 어떻게 만들 수 있을지
 생각해보자. 예를 들어, 식에 나타난 변수의 전체 개수가 3개라면 가능한
 진리값의 조합은 총 8가지(\(2 ^ 3\))이다. 각 비트의 값이 0 또는
 1이므로 이를 변수의 진리값으로 생각할 수 있다. 예를 들어 <code class="language-plaintext highlighter-rouge">000</code>은 변수
 3개 모두 거짓인 조합이고, <code class="language-plaintext highlighter-rouge">101</code>는 첫 번째와 세 번째 변수는 참이고 두
 번째 변수는 거짓인 조합이다. 이런식으로 생각하면 <code class="language-plaintext highlighter-rouge">000</code>부터 <code class="language-plaintext highlighter-rouge">111</code>까지
 총 8개의 진리값 조합이 가능하고 이는 곧 0부터 \(2 ^ {3( = 변수
 개수)}\)까지의 정수값과 같다.</p>

<p>이걸 바탕으로 변수의 진리값 조합을 나타내는 정수 <code class="language-plaintext highlighter-rouge">c</code>가 주어졌을 때
 변수 <code class="language-plaintext highlighter-rouge">id</code>에 부여된 진리값을 찾는 함수 <code class="language-plaintext highlighter-rouge">f</code>를 다음과 같이 구현할 수
 있다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">f</span> <span class="o">~</span><span class="n">c</span> <span class="n">id</span> <span class="o">=</span> <span class="n">c</span> <span class="ow">land</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">lsl</span> <span class="n">id</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>이걸 가지고 진리값 조합 하나에 대해서 두 표현식이 같은지 계산하는
 함수 <code class="language-plaintext highlighter-rouge">equal</code>을 구현할 수 있다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">equal</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">c</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="o">~</span><span class="n">c</span> <span class="k">in</span>
  <span class="n">eval</span> <span class="o">~</span><span class="n">f</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">eval</span> <span class="o">~</span><span class="n">f</span> <span class="n">e2</span>
</code></pre></div></div>

<p>앞서 말했듯 전체 조합은 0부터 \(2 ^ {변수 개수}\)만큼 가능하므로
 이를 모두 살펴봐야 한다. “모두 살펴보는 작업”에는 <code class="language-plaintext highlighter-rouge">List.for_all</code>을
 쓰고 싶으니 조합은 리스트로 생성하면 좋겠다. 이를 위한 <code class="language-plaintext highlighter-rouge">gen_comb</code>를
 구현해보자.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">gen_comb</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">max_comb</span> <span class="o">=</span> <span class="mi">1</span> <span class="ow">lsl</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">gen</span> <span class="n">v</span> <span class="n">acc</span> <span class="o">=</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">max_comb</span> <span class="k">then</span> <span class="n">acc</span> <span class="k">else</span> <span class="n">gen</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">v</span> <span class="o">::</span> <span class="n">acc</span><span class="p">)</span> <span class="k">in</span>
  <span class="n">gen</span> <span class="mi">0</span> <span class="bp">[]</span>
</code></pre></div></div>

<p>표현식 두 개와 전체 변수의 개수를 입력으로 받아서, 변수 진리값의
 가능한 모든 조합을 만든 뒤, 두 식이 같은지를 최종적으로 확인하는
 함수는 다음과 같다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">equal</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">var_num</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">for_all</span> <span class="p">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">equal</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">gen_comb</span> <span class="n">var_num</span><span class="p">)</span>
</code></pre></div></div>

<p>이제 남은 것은 입력 문자열을 파싱해서 두 개의 표현식과 거기 쓰인
 변수의 개수를 계산하는 일이다.</p>

<h2 id="파서-컴비네이터">파서 컴비네이터</h2>

<p>파싱은 파서 컴비네이터를 이용해서 구현할 것이다. 이를 위해 파서
 컴비네이터에 대해서 내가 이해한 바를 먼저 정리하고자 한다. 당연하지만
 틀리거나 설명이 부족한 부분이 무조건 있을 것이므로 자세한 것은
 <a href="#references">레퍼런스</a>를 참조하자. 간략한 개관은 위키피디아의
 <a href="https://en.wikipedia.org/wiki/Parser_combinator">Parser combinator</a>
 페이지에 꽤 잘 정리되어 있다.</p>

<h3 id="컴비네이터">컴비네이터</h3>

<p>원래 람다 대수에서 닫힌 형태 (closed form) 의 람다식, 즉 자유 변수가
 없는 람다 식을 <em>컴비네이터</em>라고 한다.  하지만 <em>파서 컴비네이터</em>
 문맥에서의 컴비네이터는 <a href="https://wiki.haskell.org/Combinator_pattern"><strong>컴비네이터
 패턴</strong></a>으로 이해하는
 것이 더 좋았다.</p>

<p>컴비네이터 패턴이란, <em>패턴</em>이라는 이름에서 알 수 있듯이 복잡한 구조를
 만들기 위해서 컴비네이터를 활용하는 디자인 패턴이다.  여기서
 컴비네이터란 함수형 언어의 고차 함수 (higher-order function) 를
 뜻한다. 기본적인 기능을 하는 함수 (primitives) 몇 가지를 먼저 만들고,
 이 함수들을 잘 합칠 수 있는 함수 (컴비네이터) 들을 만든 다음,
 이것들을 잘 조합해서 복잡한 기능을 하는 함수를 조립하는
 것이다. 함수형 커뮤니티에서는 컴비네이터 패턴이 아니라 그냥
 “컴비네이터”라고도 말하는 것 같다.</p>

<p>그리고 컴비네이터 패턴에서는 너무 당연하게도(?) 모나드가 엄청나게
 쓰이는데 (…) 그래서 아예 Monadic Parser Combinator 라고 부르기도
 한다. 근데 일단 나부터가 모나드에 대해서 잘 설명할 자신이 없고, 또
 여기서 모나드가 무엇인지를 설명하기 시작하면 글이 안드로메다로
 가버리기 때문에… 모나드에 대한 나의 이해를 짧게 정리하자면, 어떤
 <em>귀찮고 복잡한 처리</em>에 <strong>반복적으로</strong> 쓰이는 패턴을 문법적으로
 깔끔하게 처리하기 위한 디자인 패턴이다. 여기서 귀찮고 복잡한 처리에는
 파이프라이닝, 사이드 이펙트, 보일러플레이트 등이 있다. 더 자세한 것은
 위키피디아의
 <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">모나드</a>
 페이지에 더 잘 정리되어 있으니 이것을 추천한다.</p>

<p>여기까지 컴비네이터에 대해서 내가 이해한 바를 늘어 놓아
 보았다. 따라서 <em>파서</em> 컴비네이터란, 기본적인 (프리미티브) 파서를
 컴비네이터로 잘 엮어서 복잡한 구조를 파싱하는 파서를 만들기 위한
 디자인 패턴이라고 이해할 수 있다.</p>

<h3 id="파서">파서</h3>

<p>파서 컴비네이터의 문맥에서 파서는 문자열을 입력으로 받아서 해석한
 다음 (최소) <em>두 가지</em> 값을 리턴하는 <strong>함수</strong>를 뜻한다. 하나는 파서가
 파싱한 결과값 (e.g. 특정 글자 또는 파싱 트리) 이고, 다른 하나는
 파서가 <strong>파싱을 완료하고 남은 입력</strong>의 정보이다. 컴비네이터는 이 남은
 입력 정보를 활용한다. 프리미티브 파서들을 컴비네이터로 조합할 때,
 어떤 파서의 작업이 끝난 뒤 다음 파서가 작업할 위치를 이 정보로부터 알
 수 있다.</p>

<h2 id="구현">구현</h2>

<p>개인적으로 글보다는 직접 구현해 보는 것이 이해에 큰 도움이
 되었다. 특히 <a href="https://github.com/inhabitedtype/angstrom/">Angstrom</a>과
 <a href="https://github.com/tsoding/parcoom">Parcoom</a> 코드가 좋았다. 여기서
 구현한 코드는 순전히 이 문제를 풀기 위한 것이므로 프로덕션 레벨의
 구현이 궁금하다면
 <a href="https://github.com/inhabitedtype/angstrom/">Angstrom</a> 코드를 보는
 것을 추천한다.</p>

<h3 id="파서의-타입">파서의 타입</h3>

<p>먼저 파서의 타입부터 정의해보자. 앞에서 정리한 대로 파서는 입력
 문자열을 파싱한 다음 파싱 결과값과 남은 입력을 리턴하는
 함수다. <code class="language-plaintext highlighter-rouge">Angstrom</code>은 여기에 부가적인 정보를 추가해둔 덕분에 (특히
 엄청나게 큰 입력을 파싱하기 위한 처리가 되어 있어서) 입력 타입이
 <a href="https://github.com/inhabitedtype/angstrom/blob/master/lib/input.ml#L34-L40">복잡한데</a>,
 여기서는 입력이 작기 때문에 <code class="language-plaintext highlighter-rouge">string</code>이면 충분하다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">input</span> <span class="o">=</span> <span class="kt">string</span>
<span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">=</span> <span class="p">{</span> <span class="n">run</span> <span class="o">:</span> <span class="n">input</span> <span class="o">-&gt;</span> <span class="n">input</span> <span class="o">*</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="kt">string</span><span class="p">)</span> <span class="n">result</span> <span class="p">}</span>
</code></pre></div></div>

<p>입력 문자열을 파싱해서 <code class="language-plaintext highlighter-rouge">'a</code> 타입의 결과물을 만드는 파서 <code class="language-plaintext highlighter-rouge">'a parser</code>의
 타입을 정의했다. 여기에는 추가로 설명할 두 가지가 있다.</p>

<p>먼저 파서의 타입이 곧바로 함수가 아니라 <code class="language-plaintext highlighter-rouge">run</code> 이라는 필드에 파싱
 함수를 담은 레코드이다. 특별한 이유는 없고 사실 <code class="language-plaintext highlighter-rouge">Angstrom</code>과
 <code class="language-plaintext highlighter-rouge">Parcoom</code>에서 모두 이렇게 했길래 관례라고 생각해서 따라했다. (…)
 그냥 함수여도 전혀 문제가 없다. 다만 이렇게하면 나중에 파서 자체에
 (그럴만 한게 있는지는 잘 모르겠다만) 추가적인 정보를 확장할 수도
 있고, 코드를 읽을 때 “아 얘는 파서/파서 컴비네이터구나” 라는게
 명시적으로 드러나는 장점이 있는 것 같았다.</p>

<p>두 번째는 파서가 리턴하는 “파싱 결과값”의 타입이 곧바로 <code class="language-plaintext highlighter-rouge">'a</code>가 아니라
 <code class="language-plaintext highlighter-rouge">('a, string) result</code> 타입이다. <code class="language-plaintext highlighter-rouge">result</code> 는 다음과 같이 정의된
 타입인데:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Ok</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Error</span> <span class="k">of</span> <span class="k">'</span><span class="n">b</span>
</code></pre></div></div>

<p>파싱 <strong>실패</strong>를 명시적으로 알릴 수 있는 좋은 수단이다. 곧 보게
 될텐데, 어떤 파서가 <em>실패한 경우에</em> 다른 파서를 수행하는 컴비네이터가
 필요하다. 그럴려면 파싱 실패를 알리는 방법이 필요하고 이를 위해
 <code class="language-plaintext highlighter-rouge">result</code> 타입은 적절해 보인다. <code class="language-plaintext highlighter-rouge">'b</code> 타입에는 뭐든 괜찮은데 여기서는
 디버깅 메시지를 담기 위해서 <code class="language-plaintext highlighter-rouge">string</code>을 택했다. 숏코딩을 할거라면
 <code class="language-plaintext highlighter-rouge">unit</code>을 담거나 아니면 아예 결과 타입을 <code class="language-plaintext highlighter-rouge">option</code>으로 감싸도 괜찮겠다.</p>

<h3 id="프리미티브-파서">프리미티브 파서</h3>

<p>파서 컴비네이터의 재료로 쓰일 기본적인 파서 두 개를 먼저 구현해보자.</p>

<p>첫 번째는 <em>어떤 글자든 하나</em>를 파싱하는 파서 <code class="language-plaintext highlighter-rouge">any_char</code>이다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">any_char</span> <span class="o">:</span> <span class="kt">char</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="p">{</span> <span class="n">run</span> <span class="o">=</span>
      <span class="p">(</span><span class="k">fun</span> <span class="n">input</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">input</span> <span class="k">in</span>
        <span class="k">try</span> <span class="nn">String</span><span class="p">.</span><span class="n">sub</span> <span class="n">input</span> <span class="mi">1</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">,</span> <span class="nc">Ok</span> <span class="p">(</span><span class="nn">String</span><span class="p">.</span><span class="n">get</span> <span class="n">input</span> <span class="mi">0</span><span class="p">)</span> <span class="k">with</span>
        <span class="o">|</span> <span class="nc">Invalid_argument</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">,</span> <span class="nc">Error</span> <span class="s2">"empty input"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>입력 문자열이 비었으면 <code class="language-plaintext highlighter-rouge">String.sub</code> 호출 도중에 예외가 발생하므로
 <code class="language-plaintext highlighter-rouge">Error</code>를 리턴하면 된다. <code class="language-plaintext highlighter-rouge">String.sub</code>의 마지막 파라미터가 가져올 부분
 문자열의 <em>길이</em>여서 <code class="language-plaintext highlighter-rouge">(n - 1)</code>을 한 것에 주의하자.</p>

<p>다른 하나는 <code class="language-plaintext highlighter-rouge">any_char</code>와 거의 비슷한 일을 하지만 <strong>입력 문자열을
 소모하지 않는</strong> 파서 <code class="language-plaintext highlighter-rouge">peek_char</code>이다. 이 파서는
 <a href="https://en.wikipedia.org/wiki/Parsing#Lookahead">Lookahead</a>와 같은
 역할로 쓰일 수 있다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">peek_char</span> <span class="o">:</span> <span class="kt">char</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="p">{</span> <span class="n">run</span> <span class="o">=</span>
    <span class="p">(</span><span class="k">fun</span> <span class="n">input</span> <span class="o">-&gt;</span>
      <span class="k">try</span> <span class="n">input</span><span class="o">,</span> <span class="nc">Ok</span> <span class="p">(</span><span class="nn">String</span><span class="p">.</span><span class="n">get</span> <span class="n">input</span> <span class="mi">0</span><span class="p">)</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Invalid_argument</span> <span class="n">_</span><span class="o">-&gt;</span> <span class="n">input</span><span class="o">,</span> <span class="nc">Error</span> <span class="s2">"empty input"</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>이렇게 두 개의 프리미티브를 만들었다. 이것들은 이후 정의될 모나딕
 컴비네이터를 통해 조립해서 우리가 원하는 불리언 표현식을 파싱하는데
 쓰일 원재료가 된다.</p>

<h3 id="모나드">모나드</h3>

<p>파서의 타입과 프리미티브가 정의되었으니 이제 컴비네이터들을
 만들자. 먼저 가장 기본적인 모나드 세 개를 정의한다. 자세한 것은
 <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)#Definition">여기</a>를
 참조하자. 여기서부터는 타입을 같이 보는 것이 나에게는 큰 도움이
 되었기 때문에 조금 장황하지만 타입을 같이 적었다.</p>

<p>먼저 <code class="language-plaintext highlighter-rouge">'a</code> 타입을 그대로 <code class="language-plaintext highlighter-rouge">'a</code> 모나드로 감싸주는 <code class="language-plaintext highlighter-rouge">return</code> (혹은
 <code class="language-plaintext highlighter-rouge">unit</code>)이다. 달리 말하면 항상 성공해서 <code class="language-plaintext highlighter-rouge">v</code> 값을 리턴하는 <em>파서</em>를
 만들어준다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">return</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">=</span>
 <span class="k">fun</span> <span class="n">v</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">run</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">input</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">,</span> <span class="nc">Ok</span> <span class="n">v</span> <span class="p">}</span>
</code></pre></div></div>

<p>다음으로 항상 실패하는 파서를 만들어주는 <code class="language-plaintext highlighter-rouge">fail</code>이다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">fail</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">err</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">run</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">input</span> <span class="o">-&gt;</span> <span class="n">input</span><span class="o">,</span> <span class="nc">Error</span> <span class="n">err</span> <span class="p">}</span>
</code></pre></div></div>

<p>마지막으로 모나드 괴담 (?) 의 주역인 바인드이다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">bind</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">p</span> <span class="n">f</span> <span class="o">-&gt;</span>
  <span class="p">{</span> <span class="n">run</span> <span class="o">=</span>
      <span class="k">fun</span> <span class="n">input</span> <span class="o">-&gt;</span>
        <span class="k">match</span> <span class="n">p</span><span class="o">.</span><span class="n">run</span> <span class="n">input</span> <span class="k">with</span>
        <span class="o">|</span> <span class="n">input'</span><span class="o">,</span> <span class="nc">Ok</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">run</span> <span class="n">input'</span>
        <span class="o">|</span> <span class="n">input'</span><span class="o">,</span> <span class="nc">Error</span> <span class="n">err</span> <span class="o">-&gt;</span> <span class="n">input'</span><span class="o">,</span> <span class="nc">Error</span> <span class="n">err</span>
  <span class="p">}</span>
<span class="p">;;</span>

<span class="k">let</span> <span class="p">(</span> <span class="o">&gt;&gt;=</span> <span class="p">)</span> <span class="o">=</span> <span class="n">bind</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">bind p f</code>, 혹은 중위 연산자를 이용한 <code class="language-plaintext highlighter-rouge">p &gt;&gt;= f</code> 는 다음 작업을
 순차적으로 수행하는 <em>파서</em>를 만든다: 먼저 파서 <code class="language-plaintext highlighter-rouge">p</code>로 입력을
 파싱한다. 파싱에 성공하면 그 결과값을 함수 <code class="language-plaintext highlighter-rouge">f</code>에 적용해서 새 파서를
 만든 다음 남은 입력에 대해서 수행하여 결과를 리턴한다. 파서 <code class="language-plaintext highlighter-rouge">p</code>가
 파싱에 실패했다면 그대로 실패를 전파한다.</p>

<p>여기까지가 기본적인 모나드다. 파서 컴비네이터의 세계에는 몇 가지
 모나딕 컴비네이터가 더 쓰인다.</p>

<h4 id="리프팅">리프팅</h4>

<p>먼저 <a href="https://ocaml.org/p/angstrom/0.14.0/doc/Angstrom/index.html#val-lift"><code class="language-plaintext highlighter-rouge">lift</code> 패밀리
 컴비네이터</a>를
 만들 것이다. <code class="language-plaintext highlighter-rouge">lift</code> 모나드에 대한 설명은 하스켈 위키의
 <a href="https://wiki.haskell.org/Lifting">lifting</a>에 잘 정리되어 있다. 이
 컴비네이터는 함수 하나와 여러 개의 파서를 입력으로 받아서, 입력으로
 받은 파서를 <em>차례대로</em> 실행해서 값을 파싱한 다음, 파싱한 값들을
 <em>차례대로</em> 함수에 적용한 결과를 파싱하는 파서를 만든다. 보통
 <code class="language-plaintext highlighter-rouge">lift</code>부터 <code class="language-plaintext highlighter-rouge">lift2</code>, <code class="language-plaintext highlighter-rouge">lift3</code>처럼 함수의 입력 파라미터 개수에 따라
 정의되는 것 같고 타입은 다음과 같다:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">lift</span>  <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span>
<span class="k">val</span> <span class="n">lift2</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span> <span class="n">parser</span>
<span class="k">val</span> <span class="n">lift3</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">d</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">c</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">d</span> <span class="n">parser</span>
</code></pre></div></div>

<p>이를 만들기 위해서는 세 가지 컴비네이터가 필요하다.</p>

<p>먼저 <code class="language-plaintext highlighter-rouge">&gt;&gt;|</code> 모나드는 다음과 같다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span> <span class="o">&gt;&gt;|</span> <span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">p</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">p &gt;&gt;| f</code> 는 파서 <code class="language-plaintext highlighter-rouge">p</code>를 실행해서 성공한 경우 그 결과를 함수 <code class="language-plaintext highlighter-rouge">f</code>에
 적용한 값을 리턴하는 파서를 만든다. 넘겨주는 함수의 타입이 <code class="language-plaintext highlighter-rouge">('a -&gt;
 'b)</code>로, 바인드의 <code class="language-plaintext highlighter-rouge">('a -&gt; 'b parser)</code>와는 다르다는 것에
 유의하자.</p>

<p>그 다음 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code> 컴비네이터는 <code class="language-plaintext highlighter-rouge">&gt;&gt;|</code>의 파라미터 순서가 뒤집힌
 것이다. 비유하자면 빌트인 파이프라인 연산자 <code class="language-plaintext highlighter-rouge">@@</code>과 <code class="language-plaintext highlighter-rouge">|&gt;</code>의 관계와
 같다. 이 컴비네이터는 <code class="language-plaintext highlighter-rouge">fmap</code> 이라고도 불리는듯 하다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span> <span class="o">&lt;$&gt;</span> <span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">f</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span> <span class="o">&gt;&gt;|</span> <span class="n">f</span>
</code></pre></div></div>

<p>그리고 <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 컴비네이터는 다음과 같이 정의된다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span> <span class="o">&lt;*&gt;</span> <span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">f</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">f'</span> <span class="o">-&gt;</span> <span class="n">p</span> <span class="o">&gt;&gt;|</span> <span class="n">f'</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">p1 &lt;*&gt; p2</code> 는 먼저 <code class="language-plaintext highlighter-rouge">p1</code>으로 파싱한 다음 그 결과를 <code class="language-plaintext highlighter-rouge">p2</code>가 파싱한 값
 (함수) 에 적용하는 파서를 만드는 컴비네이터이다.</p>

<p>개인적으로 모나드와 함수형 프로그래밍의 놀라운 점 중 하나는 타입만
 맞추면 나머지는 잘 동작하는 점이다. 이제 위의 세 모나드를 가지고
 <code class="language-plaintext highlighter-rouge">lift</code> 패밀리를 조합해보자.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">lift</span> <span class="o">=</span> <span class="p">(</span> <span class="o">&lt;$&gt;</span> <span class="p">)</span>
<span class="k">let</span> <span class="n">lift2</span> <span class="n">f</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">p1</span> <span class="o">&lt;*&gt;</span> <span class="n">p2</span>
<span class="k">let</span> <span class="n">lift3</span> <span class="n">f</span> <span class="n">p1</span> <span class="n">p2</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">p1</span> <span class="o">&lt;*&gt;</span> <span class="n">p2</span> <span class="o">&lt;*&gt;</span> <span class="n">p3</span>
<span class="k">let</span> <span class="n">lift4</span> <span class="n">f</span> <span class="n">p1</span> <span class="n">p2</span> <span class="n">p3</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">p1</span> <span class="o">&lt;*&gt;</span> <span class="n">p2</span> <span class="o">&lt;*&gt;</span> <span class="n">p3</span> <span class="o">&lt;*&gt;</span> <span class="n">p4</span>
<span class="o">...</span>
</code></pre></div></div>

<p>먼저 <code class="language-plaintext highlighter-rouge">lift</code>는 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code>와 같다. 타입을 보면 당연하다는 것을 알 수
 있다. <code class="language-plaintext highlighter-rouge">lift2</code>는 파서 두 개를 받아서 차례로 적용한 다음 파서들이
 파싱한 값들을 차례대로 함수 <code class="language-plaintext highlighter-rouge">f</code>에 적용한 결과를 파싱하는 파서를
 만드는 컴비네이터인데, 커링 덕분에 앞서 정의한 <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code>와 <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>를
 이용해서 조립할 수 있다. <code class="language-plaintext highlighter-rouge">lift3</code>과 <code class="language-plaintext highlighter-rouge">lift4</code>는 이번 문제 풀이에는
 쓰이지 않지만 저런식으로 <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code> 컴비네이터를 이용해서 <code class="language-plaintext highlighter-rouge">liftn</code>을
 계속해서 만들어 갈 수 있음을 보여준다.</p>

<h4 id="선택-컴비네이터">선택 컴비네이터</h4>

<p>두 개의 파서가 들어왔을 때 특정 파서를 선택하는 컴비네이터도
 필요하다.</p>

<p>먼저 <code class="language-plaintext highlighter-rouge">Choice</code> 라고 불리는 컴비네이터는 다음과 같다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span> <span class="o">&lt;|&gt;</span> <span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">-&gt;</span>
  <span class="p">{</span> <span class="n">run</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="n">input</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">input'</span><span class="o">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">run</span> <span class="n">input</span> <span class="k">in</span>
      <span class="k">match</span> <span class="n">result</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Ok</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">input'</span><span class="o">,</span> <span class="nc">Ok</span> <span class="n">x</span>
      <span class="o">|</span> <span class="nc">Error</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">p2</span><span class="o">.</span><span class="n">run</span> <span class="n">ipnut</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>즉, <code class="language-plaintext highlighter-rouge">p1 &lt;|&gt; p2</code> 는 <code class="language-plaintext highlighter-rouge">p1</code>과 <code class="language-plaintext highlighter-rouge">p2</code> 중 성공하는 것을 취한다. 순서는 <code class="language-plaintext highlighter-rouge">p1</code>을
 먼저 시도해보고 실패하면 그 다음 <code class="language-plaintext highlighter-rouge">p2</code>를 시도한다.</p>

<p>이와 비슷하게 특정 결과를 버리는 컴비네이터 두 개는 다음과 같다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span> <span class="o">*&gt;</span> <span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">-&gt;</span> <span class="n">p1</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">p2</span>

<span class="k">let</span> <span class="p">(</span> <span class="o">&lt;*</span> <span class="p">)</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">p1</span> <span class="n">p2</span> <span class="o">-&gt;</span> <span class="n">p1</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">p2</span> <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">x</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">p *&gt; q</code> 는 <code class="language-plaintext highlighter-rouge">p</code> 파서가 파싱한 결과는 <em>버리고</em> <code class="language-plaintext highlighter-rouge">q</code> 파서의 결과만을
 취하는 파서를 만드는 컴비네이터이고, 반대로 <code class="language-plaintext highlighter-rouge">p &lt;* q</code>는 <code class="language-plaintext highlighter-rouge">q</code> 파서가
 파싱한 결과는 <em>버리고</em> <code class="language-plaintext highlighter-rouge">p</code> 파서의 결과만을 취하는 파서를 만드는
 컴비네이터이다.</p>

<p>여기까지, 우리가 원하는 파서를 조립하기 위해서 필요한 기본 파서와
 컴비네이터들을 살펴보았다. 이 문제를 풀기 위해서 반드시 필요한
 컴비네이터가 두 개 남아있는데, 그 전에 먼저 지금까지 만든 것들로
 파서를 어떻게 조합할 수 있는지 살펴보자.</p>

<h3 id="파서-조합하기">파서 조합하기</h3>

<p>지금까지 정의한 프리미티브 파서와 컴비네이터를 정리하면 다음과 같다.</p>

<ul>
  <li>프리미티브: <code class="language-plaintext highlighter-rouge">any_char</code>, <code class="language-plaintext highlighter-rouge">peek_char</code></li>
  <li>컴비네이터: <code class="language-plaintext highlighter-rouge">return</code>, <code class="language-plaintext highlighter-rouge">fail</code>, <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code>, <code class="language-plaintext highlighter-rouge">&gt;&gt;|</code>, <code class="language-plaintext highlighter-rouge">&lt;$&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;*&gt;</code>, <code class="language-plaintext highlighter-rouge">*&gt;</code>,
<code class="language-plaintext highlighter-rouge">&lt;*</code>, <code class="language-plaintext highlighter-rouge">&lt;|&gt;</code>, <code class="language-plaintext highlighter-rouge">lift</code></li>
</ul>

<p>아직까지 우리는 글자 하나를 무조건 받아들이는 (파싱하는) 파서와,
 입력을 소모하지 않고 글자 하나를 슬쩍 살펴보는 파서 두 개만 손에 쥐고
 있다. 이제 이것들을 조합해서 더 강력한 파서를 만들 것이다.</p>

<h4 id="기본적인-글자-파서">기본적인 글자 파서</h4>

<p>먼저 어떤 <em>조건</em>을 만족할 때에만 글자를 하나 파싱하는 파서를
 만들어보자.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">satisfy</span> <span class="n">f</span> <span class="o">=</span>
  <span class="n">peek_char</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">f</span> <span class="n">c</span> <span class="k">then</span> <span class="n">any_char</span> <span class="k">else</span> <span class="n">fail</span> <span class="s2">"not satisfied"</span>
</code></pre></div></div>

<p>만들어둔 프리미티브와 바인드 모나드가 얼마나 깔끔하게 쓰였는지 확인할
 수 있다! 먼저 <code class="language-plaintext highlighter-rouge">peek_char</code>로 글자 하나를 룩어헤드로 가져와서 조건 함수
 <code class="language-plaintext highlighter-rouge">f</code>에 적용한다. 조건이 참인 경우에는 <code class="language-plaintext highlighter-rouge">any_char</code> 파서를 수행하도록
 해서 입력을 소모하면서 글자를 파싱하고, 그렇지 않으면
 실패한다. 바인드 <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code> 가 없었다면 아래와 같이 길어질 코드였는데
 바인드 덕분에 굉장히 깔끔하게 처리된 것을 알 수 있다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* without bind *)</span>
<span class="k">let</span> <span class="n">satisfy</span> <span class="o">:</span> <span class="p">(</span><span class="kt">char</span> <span class="o">-&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">run</span> <span class="o">=</span>
    <span class="k">fun</span> <span class="n">input</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="n">peek_char</span><span class="o">.</span><span class="n">run</span> <span class="n">input</span> <span class="k">with</span>
      <span class="o">|</span> <span class="n">input'</span><span class="o">,</span> <span class="nc">Ok</span> <span class="n">x</span> <span class="o">-&gt;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="k">then</span> <span class="n">any_char</span> <span class="k">else</span> <span class="n">fail</span> <span class="s2">"not satisfied"</span>
      <span class="o">|</span> <span class="n">input'</span><span class="o">,</span> <span class="nc">Error</span> <span class="n">err</span> <span class="o">-&gt;</span> <span class="n">input'</span><span class="o">,</span> <span class="nc">Error</span> <span class="n">err</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>이제 특정 조건을 만족하는 글자 하나를 파싱할 수 있는 파서 <code class="language-plaintext highlighter-rouge">satisfy</code>를
 손에 넣었으니, 이걸 이용해서 원하는 글자 하나, 알파벳 소문자 하나,
 알파벳 대문자 하나, 숫자 글자 하나를 파싱하는 파서를 만들 수 있다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="kt">char</span> <span class="n">x</span> <span class="o">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">x</span><span class="p">)</span>
<span class="k">let</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a'</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="k">'</span><span class="n">z'</span><span class="p">)</span>
<span class="k">let</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="nc">A'</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="k">'</span><span class="nc">Z'</span><span class="p">)</span>
<span class="k">let</span> <span class="n">digit</span> <span class="o">=</span> <span class="n">satisfy</span> <span class="p">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="mi">0</span><span class="k">'</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="k">'</span><span class="mi">9</span><span class="k">'</span><span class="p">)</span>
</code></pre></div></div>

<p>글자가 아니라 <em>문자열</em>을 파싱하려면
 <a href="https://ocaml.org/p/angstrom/0.14.0/doc/Angstrom/index.html#val-take_while"><code class="language-plaintext highlighter-rouge">take_while</code></a>과
 같은 컴비네이터가 필요하지만, 이 문제에서는 변수가 항상 소문자 한
 글자이므로 살펴보지 않을 것이다.</p>

<h4 id="기본적인-구조가-있는-파서">기본적인 구조가 있는 파서</h4>

<p>이제 바인드 말고 다른 컴비네이터를 이용해서 뭔가 구조가 있는 대상을
 파싱하는 파서를 조합해보자.</p>

<p>먼저 괄호로 둘러쌓인 <em>무언가</em>를 파싱하는 파서 <code class="language-plaintext highlighter-rouge">parens</code>는 다음과 같다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">parens</span> <span class="n">p</span> <span class="o">=</span> <span class="kt">char</span> <span class="k">'</span><span class="p">(</span><span class="k">'</span> <span class="o">*&gt;</span> <span class="n">p</span> <span class="o">&lt;*</span> <span class="kt">char</span> <span class="k">'</span><span class="p">)</span><span class="k">'</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">char '('</code>로 여는 괄호를 파싱한 다음 <code class="language-plaintext highlighter-rouge">*&gt;</code> 컴비네이터를 이용해 파싱한
 괄호를 <strong>무시</strong>하고, 그 다음 파서 <code class="language-plaintext highlighter-rouge">p</code>를 실행한다음 <code class="language-plaintext highlighter-rouge">&lt;*</code> 컴비네이터로
 닫는 괄호 <code class="language-plaintext highlighter-rouge">char ')'</code>를 <strong>무시</strong>한다. 파서 컴비네이터의 장점 중 하나가
 바로 파싱하고자 하는 대상 언어의 문법을 거의 그대로 코드에 드러내는
 것인데, 매우 취향이다.</p>

<p>그 다음은 같은 파서로 두 번 파싱해서 결과를 튜플로 묶어주는 파서
 <code class="language-plaintext highlighter-rouge">pair</code>다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">pair</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span><span class="p">)</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="n">lift2</span> <span class="p">(</span><span class="k">fun</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">-&gt;</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="p">)</span> <span class="n">p</span> <span class="n">p</span>
</code></pre></div></div>

<p>바로 여기에 <code class="language-plaintext highlighter-rouge">lift</code>가 쓰였다. 파서 <code class="language-plaintext highlighter-rouge">p</code>를 두 번 실행한 결과가 각각
 <code class="language-plaintext highlighter-rouge">e1</code>과 <code class="language-plaintext highlighter-rouge">e2</code>에 전달돼서 <code class="language-plaintext highlighter-rouge">e1, e2</code>의 튜플을 파싱하는 파서가 만들어진다.</p>

<h4 id="기본적인-표현식-파서">기본적인 표현식 파서</h4>

<p>이제 기본적인 준비는 거의 다 되었다. 앞서 정의한 표현식의 타입을 다시
 살펴보자.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">expr</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">int</span>
  <span class="o">|</span> <span class="nc">And</span> <span class="k">of</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>
  <span class="o">|</span> <span class="nc">Or</span>  <span class="k">of</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>
  <span class="o">|</span> <span class="nc">Xor</span> <span class="k">of</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>
  <span class="o">|</span> <span class="nc">Neg</span> <span class="k">of</span> <span class="n">expr</span>
</code></pre></div></div>

<p>먼저 각 배리언트를 생성하는 보조 함수들을 만들자.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">var_of</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">id</span> <span class="o">-&gt;</span> <span class="nc">Var</span> <span class="n">id</span>
<span class="k">let</span> <span class="n">and_of</span> <span class="o">:</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="nc">And</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">let</span> <span class="n">or_of</span> <span class="o">:</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="nc">Or</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">let</span> <span class="n">xor_of</span> <span class="o">:</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="nc">Xor</span> <span class="p">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="p">)</span>
<span class="k">let</span> <span class="n">neg_of</span> <span class="o">:</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nc">Neg</span> <span class="n">x</span>
</code></pre></div></div>

<p>이제 이 보조 함수들을 적절히 호출해서 표현식의 각 배리언트를 파싱하는
 파서를 만들자.</p>

<h4 id="변수-파서">변수 파서</h4>

<p>변수를 파싱하는 파서를 만들기 전에, 먼저 넘버링을 위한 데이터를
 정의하자. OCaml은 명령형 프로그래밍을 잘 지원하므로 죄책감없이
 레퍼런스를 사용하면 된다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="n">ref</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">let</span> <span class="n">gen_id</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">incr</span> <span class="n">id</span> <span class="p">;</span>
  <span class="o">!</span><span class="n">id</span>

<span class="k">let</span> <span class="n">reset_id</span> <span class="bp">()</span> <span class="o">=</span> <span class="n">id</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>새로운 변수가 등장할 때마다 새로운 아이디를 부여하면 된다. 변수에
 아이디를 부여하는 것은 배열이나 딕셔너리 같은 맵핑 데이터 구조를 쓰면
 되는데 OCaml에서는 해시 테이블이 적절해보인다. 변수를 파싱할 때에만
 해시 테이블이 필요하므로 이를 파라미터로 받아오자.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">var</span> <span class="o">:</span> <span class="n">occur</span><span class="o">:</span><span class="p">(</span><span class="kt">char</span><span class="o">,</span> <span class="kt">int</span><span class="p">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">fun</span> <span class="o">~</span><span class="n">occur</span> <span class="o">-&gt;</span>
  <span class="n">lower</span> <span class="o">&gt;&gt;|</span> <span class="k">fun</span> <span class="n">var</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">find_opt</span> <span class="n">occur</span> <span class="n">var</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">id</span> <span class="o">-&gt;</span> <span class="n">var_of</span> <span class="n">id</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="n">gen_id</span> <span class="bp">()</span> <span class="k">in</span>
      <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">add</span> <span class="n">occur</span> <span class="n">var</span> <span class="n">id</span> <span class="p">;</span>
      <span class="n">var_of</span> <span class="n">id</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>변수가 등장한 순서를 넘버링할 때 쓸 해시테이블 <code class="language-plaintext highlighter-rouge">occur</code>를 받아서 실제
 변수를 파싱하는 파서는 위와 같다. 먼저 <code class="language-plaintext highlighter-rouge">lower</code> 파서로 소문자를 하나
 파싱한다. 그리고 <code class="language-plaintext highlighter-rouge">&gt;&gt;|</code> 모나드를 이용해서 파싱 결과 <code class="language-plaintext highlighter-rouge">var</code>를 가져와서
 표현식을 만들건데, 이때 <code class="language-plaintext highlighter-rouge">occur</code>에서 넘버링이 있으면 그걸 써서 <code class="language-plaintext highlighter-rouge">Var</code>를
 만들고 없으면 새로 만든다.</p>

<h4 id="단항-연산식-파서">단항 연산식 파서</h4>

<p>다음으로 연산자에 대한 파서를 만들어보자. 일단 가장 쉬워보이는 단항
 연산식은 다음과 같다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* unary operator *)</span>
<span class="k">let</span> <span class="n">neg</span> <span class="o">:</span> <span class="n">expr</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="kt">char</span> <span class="k">'</span><span class="o">~</span><span class="k">'</span> <span class="o">*&gt;</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;&gt;|</span> <span class="n">neg_of</span><span class="p">)</span>
</code></pre></div></div>

<p>여기서는 <code class="language-plaintext highlighter-rouge">*&gt;</code> 컴비네이터가 일종의 <em>조건문</em>으로 활용되는 것을 볼 수
 있다. <code class="language-plaintext highlighter-rouge">~</code>를 만난 경우에만, 그 뒤의 표현식을 파싱한 다음 <code class="language-plaintext highlighter-rouge">neg_of</code>로
 감싸준다. 이때 <code class="language-plaintext highlighter-rouge">~</code> 자체를 만났다는 사실만 중요하므로 이를 파싱한 결과
 자체는 버려도 된다. <code class="language-plaintext highlighter-rouge">~</code>를 만나지 못했다면, 즉 파싱에 실패했다면
 아무것도 하지 말아야 하므로 컴비네이터의 의도와도 잘 맞다.</p>

<p>그런데 이 파서의 타입을 잘 보면 <code class="language-plaintext highlighter-rouge">expr parser</code>가 아니라, 부정 연산으로
 만들기 위한 대상 표현식을 파싱하기 위해서 타입이 <code class="language-plaintext highlighter-rouge">(expr parser -&gt;
 expr parser)</code>인 것을 알 수 있다. 표현식 파서를 만들려고 단항 연산식
 파서를 만들려는데, 입력으로 표현식 파서가 들어와야 한다니 조금 모순된
 상황이다. 이에 대해서는 곧 설명할 Fixed Point 컴비네이터가
 해결해준다.</p>

<h4 id="이항-연산식-파서">이항 연산식 파서</h4>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* binary operators *)</span>
<span class="k">let</span> <span class="n">and_</span> <span class="o">:</span> <span class="p">(</span><span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span><span class="p">)</span> <span class="n">parser</span> <span class="o">=</span> <span class="kt">char</span> <span class="k">'</span><span class="o">&amp;</span><span class="k">'</span> <span class="o">*&gt;</span> <span class="n">return</span> <span class="n">and_of</span>
<span class="k">let</span> <span class="n">or_</span> <span class="o">:</span> <span class="p">(</span><span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span><span class="p">)</span> <span class="n">parser</span> <span class="o">=</span> <span class="kt">char</span> <span class="k">'</span><span class="o">|</span><span class="k">'</span> <span class="o">*&gt;</span> <span class="n">return</span> <span class="n">or_of</span>
<span class="k">let</span> <span class="n">xor</span> <span class="o">:</span> <span class="p">(</span><span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">expr</span><span class="p">)</span> <span class="n">parser</span> <span class="o">=</span> <span class="kt">char</span> <span class="k">'</span><span class="o">^</span><span class="k">'</span> <span class="o">*&gt;</span> <span class="n">return</span> <span class="n">xor_of</span>
</code></pre></div></div>

<p>이항 중위 연산의 경우는 조금 더 복잡하다. 중위 연산 표현식을 제대로
 파싱하려면 (1) 왼쪽항의 <em>표현식</em>을 먼저 파싱한 다음, (2) 중위
 연산자를 파싱하여 그에 맞는 배리언트의 생성자를 꺼내오고, (3)
 오른쪽항의 <em>표현식</em>을 마저 파싱해서 (4) 최종적으로는 좌항과 우항의
 식을 생성자로 묶어야 한다. 위의 함수들은 (2)의 역할을 하는
 함수들이다. 이 과정을 다른 언어로 구현했다면 스택을 이용해서
 구현했겠지만, 파서 컴비네이터로는 좀더 깔끔하게 할 수 있다.</p>

<p>위의 (1)-(4) 과정을 조금 더 일반화해서, 중첩된 중위 표현식을 파싱하는
 과정은 다음과 같다.</p>
<ol>
  <li>먼저 가장 왼쪽항을 파싱한다.</li>
  <li>
    <p>왼쪽항 다음의 중위 연산자와 표현식 하나를 파싱한다.</p>

    <p>2.1. (a) 파싱에 성공한 경우, 중위 연산자의 생성자로 이때까지
   파싱한 결과를 묶는다. 그리고 (b) 다시 2.로 돌아가서 중위
   연산자와 표현식 하나를 계속해서 파싱한다.</p>

    <p>2.2. 파싱에 실패한 경우, 이때까지 파싱한 결과를 곧바로
   리턴한다. 만약 중위 연산자 파싱에 처음부터 실패했다면 곧바로
   1.의 왼쪽항을 리턴한 것과 같다.</p>
  </li>
</ol>

<p>이 과정은 파싱하고자 하는 대상이 조금만 복잡해져도 필수적이다. 딱히
 정해진 이름이 있는 것 같진 않지만 <a href="https://github.com/inhabitedtype/angstrom/#usage">Angstrom에서는
 <code class="language-plaintext highlighter-rouge">chainl1</code></a>이라는
 함수가 있더라. 아마 ‘왼쪽항 1개’를 누적해가면서 파싱해간다는 뜻이
 아닐까 싶다. 나도 유사하게 <code class="language-plaintext highlighter-rouge">chain</code>이라는 함수를 정의했다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">chain</span> <span class="n">expr</span> <span class="n">op</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">further</span> <span class="n">acc</span> <span class="o">=</span>
    <span class="c">(* 2. *)</span>
    <span class="n">lift2</span> <span class="p">(</span><span class="k">fun</span> <span class="n">constructor</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">constructor</span> <span class="n">acc</span> <span class="n">x</span> <span class="c">(* 2.1. (a) *)</span> <span class="p">)</span> <span class="n">op</span> <span class="n">expr</span>
    <span class="o">&gt;&gt;=</span> <span class="n">further</span> <span class="c">(* 2.1. (b) *)</span> <span class="o">&lt;|&gt;</span> <span class="n">return</span> <span class="n">acc</span> <span class="c">(* 2.2. *)</span>
  <span class="k">in</span>
  <span class="n">expr</span> <span class="c">(* 1. *)</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">init</span> <span class="o">-&gt;</span> <span class="n">further</span> <span class="n">init</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>함수는 위의 과정을 거의 그대로 따라가고 있다. 1:1 대응은 아니지만
 위의 과정에 해당하는 부분을 주석으로 적어두었다. 먼저 <code class="language-plaintext highlighter-rouge">expr</code>로
 표현식을 파싱하는데, 이는 가장 왼쪽항이므로 중위 연산 체이닝의
 초기값이다. 그래서 <code class="language-plaintext highlighter-rouge">&gt;&gt;=</code> 에 넘겨줄 때 <code class="language-plaintext highlighter-rouge">init</code>으로 네이밍했다. 그 후
 중위연산자를 만날 때마다 계속해서 그에 맞는 생성자 (<code class="language-plaintext highlighter-rouge">constructor</code>) 를
 호출해서 중위 표현식을 누적한다. 이 리프팅의 결과를 가지고 다시
 <code class="language-plaintext highlighter-rouge">further</code>를 호출해서 앞에서 말한 과정을 반복하거나, 혹은 반복에 실패
 (정확히는 리프팅의 첫 번째 파서인 <code class="language-plaintext highlighter-rouge">op</code>, 즉 연산자 파싱에 실패) 한
 경우 이때까지 쌓은 결과값을 곧바로 리턴한다. 내 취향의 코드다.</p>

<p><code class="language-plaintext highlighter-rouge">lift2</code>에 전달한 함수 파라미터와 파서의 순서에 주목하자. <code class="language-plaintext highlighter-rouge">init</code>에서
 이미 왼쪽항의 표현식을 파싱했으므로 그 다음은 중위 연산자 <code class="language-plaintext highlighter-rouge">op</code>를
 파싱하고 그 다음 표현식 <code class="language-plaintext highlighter-rouge">expr</code>을 파싱해야 한다. 그리고 리프팅 함수에
 있는 생성자 (<code class="language-plaintext highlighter-rouge">constroctur</code>) 가 바로 위에서 정의한 이항 연산자 파서들
 <code class="language-plaintext highlighter-rouge">and_</code>, <code class="language-plaintext highlighter-rouge">or_</code>, <code class="language-plaintext highlighter-rouge">xor</code>이 파싱한 결과 <code class="language-plaintext highlighter-rouge">and_of</code>, <code class="language-plaintext highlighter-rouge">or_of</code>, <code class="language-plaintext highlighter-rouge">xor_of</code>인데,
 이전에 파싱해서 누적된 <code class="language-plaintext highlighter-rouge">acc</code>가 먼저 온 것을 볼 수 있다. 예를 들어
 <code class="language-plaintext highlighter-rouge">a + b + c</code>를 체이닝하게 되면 <code class="language-plaintext highlighter-rouge">((a + b) + c)</code>로 묶여야 하는 것과
 같다. 함수형에서의 <code class="language-plaintext highlighter-rouge">fold_left</code> 와도 비슷하다.</p>

<p>이제 우리는 이항 연산자 (의 생성자를 돌려주는) 파서 <code class="language-plaintext highlighter-rouge">and_</code>, <code class="language-plaintext highlighter-rouge">or_</code>,
 <code class="language-plaintext highlighter-rouge">xor</code>과, 중위 연산식을 체이닝할 수 있는 컴비네이터 <code class="language-plaintext highlighter-rouge">chain</code>을 이용해서
 중위 연산식 파싱할 수 있을 것 같다. 그런데, 단항 연산 파서의 타입과
 마찬가지로, 이항 연산의 좌항과 우항을 파싱하려면 표현식 파서가 있어야
 한다. 그런데 지금 우리가 만들려고 하는게 표현식 파서다. 뭔가 모순적인
 상황임을 알 수 있다. 표현식 파서를 만들려고 하는데 표현식 파서가
 필요한 것이다. 그 이유는 표현식 자체가 <strong>귀납적으로</strong> 정의된 타입이기
 때문이다. 따라서, <em>귀납적인 자료구조를 파싱할 수 있게 해주는
 컴비네이터</em>가 필요하다.</p>

<h4 id="fixed-point-컴비네이터">Fixed Point 컴비네이터</h4>

<p>X를 파싱하기 위해서 X 파서가 필요한 상황은 사실 프로그래밍 언어의
 세계에서는 흔한 일이다. 예로 JSON을 생각해보자. JSON의 배열 혹은
 오브젝트에 들어갈 수 있는 값은 그 자체로 JSON이다. 이런 재귀적인 값을
 파싱하는 파서 컴비네이터는 어떻게 만들어야 할까?</p>

<p>OCaml에는 재귀적인 값을 정의할 수 있게 해주는 키워드 <code class="language-plaintext highlighter-rouge">rec</code>이 있으니,
 다음과 같이 구현하면 어떨까?</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">expr</span> <span class="o">:</span> <span class="n">expr</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="n">neg</span> <span class="n">expr</span> <span class="o">&lt;|&gt;</span> <span class="n">parens</span> <span class="n">expr</span> <span class="o">&lt;|&gt;</span> <span class="n">var</span> <span class="o">~</span><span class="n">occur</span>
</code></pre></div></div>

<p>하지만 이렇게하면 다음과 같은 에러 메시지가 뜬다:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This kind of expression is not allowed as right-hand side of `let rec'
</code></pre></div></div>

<p>대체 무슨 일이 일어난건지
 <a href="https://v2.ocaml.org/manual/letrecvalues.html#s:letrecvalues">매뉴얼</a>을
 좀 찾아보니, 몰랐던 사실 하나를 깨달았다. OCaml에서 <code class="language-plaintext highlighter-rouge">let rec</code>
 키워드로 만들 수 있는 재귀적인 값에는 제한이 있었다: <strong>함수가 아닌
 값</strong>만 가능하다. 이게 무슨 말이냐 하면…</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">let rec expr foo bar = ... </code>에서 <code class="language-plaintext highlighter-rouge">expr</code>은 <strong>함수</strong> 다.</li>
  <li><code class="language-plaintext highlighter-rouge">let rec expr = ...</code> 에서 <code class="language-plaintext highlighter-rouge">expr</code>은 <strong>값</strong> 이다.</li>
</ul>

<p>즉, 파라미터 없이 <code class="language-plaintext highlighter-rouge">let</code> (또는 <code class="language-plaintext highlighter-rouge">let rec</code>) 로 선언된 이름은 항상
 값이다. 그러므로 값을 정의하는 본문 안에서 이를 함수로 쓸 수 없다!
 (우리의 파서 타입은 <code class="language-plaintext highlighter-rouge">run</code>을 담은 레코드이지만, 실제로 <code class="language-plaintext highlighter-rouge">run</code>의 타입이
 함수이기 때문에 타입 체커가 이렇게 동작한다)</p>

<p>그러면 의미없는 파라미터를 줘서 강제로 함수로 만들면 되지 않을까?</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">expr</span> <span class="bp">()</span> <span class="o">=</span>
  <span class="n">neg</span> <span class="p">(</span><span class="n">expr</span> <span class="bp">()</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="n">parens</span> <span class="p">(</span><span class="n">expr</span> <span class="bp">()</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="n">var</span> <span class="o">~</span><span class="n">occur</span>
</code></pre></div></div>

<p>이렇게하면 타입 검사는 통과하지만, 코드를 제출하면 <strong>메모리 초과</strong>가
 뜬다. <code class="language-plaintext highlighter-rouge">neg</code> (또는 <code class="language-plaintext highlighter-rouge">parens</code>) 컴비네이터에 넘겨줘야 하는 타입은
 파서인데, 이를 만들기 위해서 <code class="language-plaintext highlighter-rouge">expr ()</code> 이라는 함수를 호출하고, 그러면
 호출한 <code class="language-plaintext highlighter-rouge">expr ()</code> 안에서 또 컴비네이터에 넘겨줄 파서를 만들기 위해서
 호출하고… 의 과정을 거쳐 스택 오버플로우가 발생하는 것이다.</p>

<p>그러면 대체 어떻게 해야 재귀적인 파서를 만들어주는 컴비네이터를 만들
 수 있을까?</p>

<p>막혔을 때는 망설임없이 선인들의 지혜를 살펴보는 것이 좋다. 먼저
 <code class="language-plaintext highlighter-rouge">Parcoom</code>에는 이와 유사한
 <a href="https://github.com/tsoding/parcoom/blob/main/src/parcoom.ml#L129-L143"><code class="language-plaintext highlighter-rouge">many</code></a>라는
 컴비네이터가 있는데, 이는 파싱에 실패할 때까지 계속 파싱해서 리스트로
 결과를 쌓아주는 컴비네이터이다. 뇌에 힘을 줘서 이 구현을 참조하면
 원하는 컴비네이터를 만들 수 있겠지만 여기서는 다른 방식으로 구현할
 것이다.</p>

<p>왜냐하면 <code class="language-plaintext highlighter-rouge">Angstrom</code>에 더 멋진 해결책이 있기 때문이다. 재귀적인
 데이터를 파싱한다고 해서 무한히 파싱 가능한 것은 아니다. 파싱한
 결과를 계속 쌓아 나아가다 보면 결과가 더 이상 쌓이지 않는 시점이
 오는데, 이를 보통 Fixed Point라고 하고 이를 계산해주는 컴비네이터를
 <a href="https://en.wikipedia.org/wiki/Fixed-point_combinator">Fixed Point
 컴비네이터</a>라고
 한다. 그리고 <code class="language-plaintext highlighter-rouge">Angstrom</code>의
 <a href="https://ocaml.org/p/angstrom/0.14.0/doc/Angstrom/index.html#val-fix"><code class="language-plaintext highlighter-rouge">fix</code></a>가
 정확히 이 역할을 한다. 파서의 Fixed Point를 계산해주는 파서를
 만들어주는 컴비네이터이다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">fix</span> <span class="o">:</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">parser</span> <span class="o">=</span>
  <span class="k">fun</span> <span class="n">f</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="k">rec</span> <span class="n">p</span> <span class="o">=</span> <span class="k">lazy</span> <span class="p">(</span><span class="n">f</span> <span class="n">r</span><span class="p">)</span>
    <span class="ow">and</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{</span> <span class="n">run</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">input</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nn">Lazy</span><span class="p">.</span><span class="n">force</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">run</span> <span class="n">input</span> <span class="p">}</span> <span class="k">in</span>
    <span class="n">r</span>
</code></pre></div></div>

<p>재귀적인 함수 값을 정의하기 위해서 스스로를 파라미터로 받는 함수를
 만들어서 적용했다. 여기 적용된 기법은 <a href="https://wiki.haskell.org/Tying_the_Knot">신발 끈 묶기
 기법(Tying-the-knot
 technique)</a>이라고 하는 것
 같은데, 재귀적으로는 불가능해 보이는 것들을 정의하게 해주는
 기법이다. <code class="language-plaintext highlighter-rouge">Angstrom</code>은 <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">Lazy
 evaluation</a>을 이용해서
 이를 구현하고 있는데, <code class="language-plaintext highlighter-rouge">Lazy</code>를 벗겨내면 위 코드는 아래 코드와
 동일하다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">fix</span> <span class="n">f</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{</span> <span class="n">run</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">input</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">run</span> <span class="n">input</span> <span class="p">}</span> <span class="k">in</span>
  <span class="n">r</span>
</code></pre></div></div>

<p>즉, <code class="language-plaintext highlighter-rouge">fix (fun r -&gt; ...)</code>은 <code class="language-plaintext highlighter-rouge">r</code>을 재귀적으로 적용할 수 있는 파서를
 만들어준다. 코드를 보면, 함수 <code class="language-plaintext highlighter-rouge">f</code>의 파라미터 <code class="language-plaintext highlighter-rouge">r</code>은 <code class="language-plaintext highlighter-rouge">fix f</code>가 리턴하는
 (즉, 만들고자 하는) 파서 <code class="language-plaintext highlighter-rouge">fix (fun r -&gt; ...)</code>과 같다는 것을 알 수
 있다. <code class="language-plaintext highlighter-rouge">r</code>을 호출하지 않고 파싱에 성공한 경우는 더 이상 재귀호출이
 없으므로 종료된다.</p>

<p>예를 들어, 우리의 표현식을 생각해보자. <code class="language-plaintext highlighter-rouge">Var</code>를 제외한 나머지 타입은
 귀납적으로 정의되어 있어서, <code class="language-plaintext highlighter-rouge">expr</code>을 파싱하려면 <code class="language-plaintext highlighter-rouge">expr</code> 파서를
 호출해야 한다. 따라서 코드를 다음과 같이 작성할 수 있다:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">fix</span> <span class="p">(</span><span class="k">fun</span> <span class="n">expr</span> <span class="o">-&gt;</span> <span class="n">var</span> <span class="o">&lt;|&gt;</span> <span class="n">parens</span> <span class="n">expr</span> <span class="o">&lt;|&gt;</span> <span class="o">...</span> <span class="p">)</span>
</code></pre></div></div>

<p>여기서 <code class="language-plaintext highlighter-rouge">fix</code>에 전달된 함수 파라미터 <code class="language-plaintext highlighter-rouge">expr</code>은 정의하고자 하는 표현식
 파서 <code class="language-plaintext highlighter-rouge">expr</code>과 같다.</p>

<h3 id="표현식-파서-드디어">표현식 파서 (드디어)</h3>

<p>이제 우리 손에 있는 고급 파서들과 다양한 컴비네이터들을 이용하면
 드디어 표현식 파서를 만들 수 있을 것 같다. 나이브하게는 다음과 같이
 구현할 수 있다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">expr</span> <span class="o">~</span><span class="n">occur</span> <span class="o">=</span>
  <span class="n">fix</span> <span class="p">(</span><span class="k">fun</span> <span class="n">expr</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">fix</span> <span class="p">(</span><span class="k">fun</span> <span class="n">factor</span> <span class="o">-&gt;</span>
        <span class="n">neg</span> <span class="n">factor</span> <span class="o">&lt;|&gt;</span> <span class="n">parens</span> <span class="n">expr</span> <span class="o">&lt;|&gt;</span> <span class="n">var</span> <span class="o">~</span><span class="n">occur</span><span class="p">))</span>
     <span class="k">in</span>
    <span class="n">chain</span> <span class="n">factor</span> <span class="n">and_</span> <span class="o">&lt;|&gt;</span> <span class="n">chain</span> <span class="n">factor</span> <span class="n">xor</span> <span class="o">&lt;|&gt;</span> <span class="n">chain</span> <span class="n">factor</span> <span class="n">or_</span>
</code></pre></div></div>

<p>체이닝과 Fixed point 컴비네이터를 이용해서 <code class="language-plaintext highlighter-rouge">factor</code>와 중위 연산식을
 파싱했다. <code class="language-plaintext highlighter-rouge">factor</code>는 단항 연산식이거나, 괄호로 둘러쌓인 표현식 그
 자체이거나, 변수이다. 표현식은 <code class="language-plaintext highlighter-rouge">factor</code>가 <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">xor</code>, <code class="language-plaintext highlighter-rouge">or</code> 중위
 연산으로 계속 체이닝될 수 있다.</p>

<p>하지만 이렇게 파싱해서 제출하면 틀린 답이 나온다. 왜냐하면 위의
 파서는 <strong>연산자의 우선순위</strong>를 고려하지 않았기 때문이다. 문제의
 조건인 C의 연산자 우선순위에 따르면 <code class="language-plaintext highlighter-rouge">~</code>, <code class="language-plaintext highlighter-rouge">&amp;</code>, <code class="language-plaintext highlighter-rouge">^</code>, <code class="language-plaintext highlighter-rouge">|</code> 순이다. 마지막
 <code class="language-plaintext highlighter-rouge">&lt;|&gt;</code> 컴비네이터에 묶인 순서가 <code class="language-plaintext highlighter-rouge">and_</code>, <code class="language-plaintext highlighter-rouge">xor</code>, <code class="language-plaintext highlighter-rouge">or_</code>이니 우선순위를
 지킨게 아닌가 하는 생각이 들 수도 있지만, 실제로는 그렇지 않다. 예를
 들어 <code class="language-plaintext highlighter-rouge">a | b &amp; c</code> 를 파싱하면 <code class="language-plaintext highlighter-rouge">(a | (b &amp; c))</code>로 파싱되어야 하는데,
 위의 파서는 <code class="language-plaintext highlighter-rouge">((a | b) &amp; c)</code>로 파싱하게 된다. 즉, <code class="language-plaintext highlighter-rouge">&lt;|&gt;</code> 컴비네이터는
 우선순위를 부여하지 못한다.</p>

<p>어떻게 우선순위를 줄 수 있을까? 파서 컴비네이터에서 우선순위를 주는
 방법은 매우 간단하다: 대상 언어의 <strong>문법</strong>을 정확히 작성하는
 것이다. BNF에서는 논터미널의 심볼의 깊이가 깊을수록 우선순위가 높다.
 따라서 단항 연산자 <code class="language-plaintext highlighter-rouge">~</code>가 가장 깊숙한 곳에 있고, 그 후 순서대로 <code class="language-plaintext highlighter-rouge">&amp;</code>,
 <code class="language-plaintext highlighter-rouge">^</code>, <code class="language-plaintext highlighter-rouge">|</code>가 있는 문법을 정의하면 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXPR := TERM0 or TERM0
      | TERM0

TERM0 := TERM1 xor TERM1
      | TERM1

TERM1 := FACTOR and FACTOR
      | FACTOR

FACTOR := VAR
       | ( EXPR )
       | not FACTOR
</code></pre></div></div>

<p>이 올바른 문법을 바탕으로 정확한 표현식 파서를 만들 수 있다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">expr</span> <span class="o">:</span> <span class="n">occur</span><span class="o">:</span><span class="p">(</span><span class="kt">char</span><span class="o">,</span> <span class="kt">int</span><span class="p">)</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">expr</span> <span class="n">parser</span> <span class="o">=</span> <span class="k">fun</span> <span class="o">~</span><span class="n">occur</span> <span class="o">-&gt;</span>
  <span class="n">fix</span> <span class="p">(</span><span class="k">fun</span> <span class="p">(</span><span class="n">expr</span> <span class="o">:</span> <span class="n">expr</span> <span class="n">parser</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">factor</span> <span class="o">=</span>
        <span class="n">fix</span> <span class="p">(</span><span class="k">fun</span> <span class="n">factor</span> <span class="o">-&gt;</span> <span class="n">neg</span> <span class="n">factor</span> <span class="o">&lt;|&gt;</span> <span class="n">parens</span> <span class="n">expr</span> <span class="o">&lt;|&gt;</span> <span class="n">var</span> <span class="o">~</span><span class="n">occur</span><span class="p">)</span>
      <span class="k">in</span>
      <span class="k">let</span> <span class="n">term1</span> <span class="o">=</span> <span class="n">chain</span> <span class="n">factor</span> <span class="n">and_</span> <span class="k">in</span>
      <span class="k">let</span> <span class="n">term0</span> <span class="o">=</span> <span class="n">chain</span> <span class="n">term1</span> <span class="n">xor</span> <span class="k">in</span>
      <span class="n">chain</span> <span class="n">term0</span> <span class="n">or_</span> <span class="p">)</span>
</code></pre></div></div>

<p>드디어 표현식 파서를 완성했다! 문법을 거의 그대로 닮은 아름다운
 코드이다.</p>

<p>이제 남은 일은 입력을 다듬어서 파싱한 뒤 두 식을 비교하고 문제의
 조건에 맞게 출력하는 것이다. 입력 표현식은 공백도 포함하는데, 우리는
 공백을 파싱하는 파서는 따로 만들지 않았다. 괄호와는 달리 공백은
 표현식의 의미에 영향을 끼치지 않아서 그냥 전처리로 공백을 없애버리는
 것이 훨씬 쉽기 때문이다. 공백을 없애는 <code class="language-plaintext highlighter-rouge">remove_blanks</code>를 만들어서
 입력을 다듬자.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">remove_blanks</span> <span class="n">s</span> <span class="o">=</span>
  <span class="nn">String</span><span class="p">.</span><span class="n">to_seq</span> <span class="n">s</span> <span class="o">|&gt;</span> <span class="nn">Seq</span><span class="p">.</span><span class="n">filter</span> <span class="p">(</span><span class="k">fun</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span> <span class="o">&lt;&gt;</span> <span class="k">'</span> <span class="k">'</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="nn">String</span><span class="p">.</span><span class="n">of_seq</span>
</code></pre></div></div>

<p>파이프라이닝 코드는 역시 내 취향이다.</p>

<p>이제 최종적으로 문자열을 입력으로 받아서 우리가 만든 표현식 파서로
 파싱을 하는 함수를 구현할 수 있다. 파서 컴비네이터를 올바르게
 구현했다면 두 표현식을 구분하는 일은 아주 쉽다: 그냥 순차적으로 두 번
 파싱하면 된다. 같은 파서를 두 번 적용해서 튜플로 만들어주는
 컴비네이터 <code class="language-plaintext highlighter-rouge">pair</code>를 이용하면 좋을 것 같다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">parse_expr</span> <span class="n">s</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">occur</span> <span class="o">=</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">create</span> <span class="mi">10</span> <span class="k">in</span>
  <span class="n">reset_id</span> <span class="bp">()</span> <span class="p">;</span>
  <span class="k">let</span> <span class="n">input</span> <span class="o">=</span> <span class="n">remove_blanks</span> <span class="n">s</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">expr_parser</span> <span class="o">=</span> <span class="n">pair</span> <span class="p">(</span><span class="n">expr</span> <span class="o">~</span><span class="n">occur</span><span class="p">)</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">expr_parser</span><span class="o">.</span><span class="n">run</span> <span class="n">input</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">_</span><span class="o">,</span> <span class="nc">Ok</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">r</span><span class="o">,</span> <span class="nn">Hashtbl</span><span class="p">.</span><span class="n">length</span> <span class="n">occur</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">_</span><span class="o">,</span> <span class="nc">Error</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="n">e</span>
<span class="p">;;</span>
</code></pre></div></div>

<p>이렇게 파싱한 두 개의 표현식과 변수 개수를 가지고 앞에서 정의한
 <code class="language-plaintext highlighter-rouge">equal</code> 함수를 이용해 모든 조합을 비교하고 결과를 출력 형태에 맞게 잘
 출력하면 4ms의 솔루션을 얻을 수 있다. 자세한 코드는
 <a href="https://github.com/sangwoo-joh/ocaml-ps/blob/master/boj/2769.ml">여기</a>서
 확인할 수 있다.</p>

<hr />

<p>정말 오랜만에 OCaml PS 시리즈 글을 썼다. 문제 푸는데는 이틀 정도
 걸렸는데 이 글을 쓰는데는 2주가 넘게 걸린 것 같다. 만족스럽게 쓰여진
 부분도 있지만 몇 번을 읽어도 부족해보이는 부분도 많다. 역시 글쓰기는
 어렵다.</p>

<p>올해는 OCaml 5.0이 세상에 공개된 뜻깊은 해이다. 드디어 Parallelism과
 Concurrency가 언어 레벨에서 지원된다. OCaml로 직업적인 코딩을 할 수는
 없으니 아마도 당분간 5.0을 쓸 기회는 없겠지만, 사람 일이라는 게
 어떻게 될지 모르니 일단은 내가 할 수 있는 방법인 “OCaml로 PS
 하기”라도 꾸준히 할 수 있길 바란다.</p>

<hr />

<h2 id="references">References</h2>
<ul>
  <li><a href="https://www.acmicpc.net/blog/view/66">OCaml로 문제 풀이하기</a></li>
  <li><a href="https://ocaml.org/p/angstrom/0.14.0/doc/Angstrom/index.html">Angstrom</a></li>
  <li><a href="https://www.youtube.com/watch?v=Y5IIXUBXvLs">Fast Parser Combinator Library from Scrach in OCaml (no
dependencies)</a></li>
  <li><a href="https://github.com/tsoding/parcoom">Parcoom</a></li>
  <li><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi0s7nUqrb6AhUkyYsBHUOaD-AQFnoECA0QAQ&amp;url=https%3A%2F%2Fwww.cs.nott.ac.uk%2F~pszgmh%2Fmonparsing.pdf&amp;usg=AOvVaw3LtR393c7YLbVqqhMb24Ty">Monadic Parser
Combinators</a></li>
  <li><a href="https://wiki.haskell.org/Combinator_pattern">Combinator pattern</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Parser_combinator">Parser
combinator</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">Monad</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">Recursive descent parser</a></li>
  <li><a href="https://wiki.haskell.org/Tying_the_Knot">Tying-the-knot</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Lazy_evaluation">Lazy evaluation</a></li>
</ul>]]></content><author><name>sangwoo-joh</name></author><category term="dev" /><category term="ocaml" /><summary type="html"><![CDATA[풀고 싶었던 문제를 드디어 풀었다.]]></summary></entry><entry><title type="html">허리 건강과 잠</title><link href="https://sangwoo-joh.github.io/healthy-life" rel="alternate" type="text/html" title="허리 건강과 잠" /><published>2022-05-06T00:00:00+00:00</published><updated>2022-05-06T00:00:00+00:00</updated><id>https://sangwoo-joh.github.io/healthy-life</id><content type="html" xml:base="https://sangwoo-joh.github.io/healthy-life"><![CDATA[<p>나에게는 꾸준히 찾아오는 고통이 있는데 바로 허리 디스크다. 기억 나는
 것만 정리해보자면..</p>
<ul>
  <li>고등학생 시절 모의고사 치다가 1교시 언어 영역 끝나고 디스크 터져서
실려갔던 일을 시작으로…</li>
  <li>대학원 시절 데드리프트 하다가 뻑!하고 걷지도 못할 정도로 심하게
터져서 두 세달 정도 고생했던 것과..</li>
  <li>엘리베이터가 고장나서 아들(10kg 이상)을 안고 20층 넘는 계단
오르기를 하다가 급격하게 안좋아져서 일어나지도 못한 것이 가장 최근 일이다.</li>
</ul>

<p>고등학생 때부터 터졌으니 그때부터 정신차리고 관리했어야 했는데, 도통
 몸 쓰는 일에는 관심을 갖지 못해서 여기까지 와버렸다. 그나마
 부모님께서 내 하찮은 허리 내구도를 미리 눈치채시고 괜찮은 보험을
 들어주셔서 경제적인 고통은 크지 않았다. 하지만 디스크의 물리적 고통은
 정말 어마어마하다. 너무 아파서 눈물이 찔끔 날 정도로 강렬하게 기억에
 남는 것들만 나열한 것이 위의 것들인데, 이외에도 일상 생활에 불편함을
 초래할 정도의 다양한 고통은 꽤 자주 찾아온다.</p>

<p>그래서 정선근 TV와 기타 건강/운동 유튜브를 섭렵하며 걷기, 오래
 앉아있지 않기, 신전 자세 자주 취하기 등을 하고 있지만, 20여년을 나쁜
 자세로 살아온 사람이 며칠 바른 자세 한다고 급격하게 좋아지진
 않는다. 매일매일 조금씩 나아지는 것 같고 최소한 더 나빠지지는 않도록
 유지하는데 집중하고 있다.</p>

<p>그러던 중 올해 들어서 체감한 변화가 있다. 요즘 점점 아들이
 육체적으로나 정신적으로나 많이 성장한 것이 느껴져서 놀아주는데 체력이
 부치고 있는데, 그 덕분에 아들이랑 자는 시간이 점점 동기화되고 있다
 (…). 예를 들어 주말에는 오전에 한탕 놀아주고 나면 꼭 오후에 낮잠을
 자는데 그때 나도 무조건 1~2시간은 자게 되고, 주중이든 주말이든 늦어도
 9시 반에는 잠자리에 들어서 대략 1시간정도 안에는 재우려고 하는데
 그러다보면 어느새 나도 같이 잠들어버린다. 일주일 중 저녁 11시 이전에
 깨어있는 날이 드물 정도로 잘 자버리고 있는 것이다. 매일 꼬박꼬박
 8~9시간은 자는 것 같다. 고등학생 시절부터 늘 새벽에 초롱초롱한 눈으로
 다양한 잉여짓을 하다 늦게 잠들어서 5~7시간씩 자는 것을 10년 가까이
 해온 덕분에, 이런 변화가 굉장히 낯설다.</p>

<p>그런데 또 한편으로는, 덕분에 하루하루가 꽤 활기차진다(?). 잠이
 보약이라는 말을 무섭도록 몸소 겪고 있다. 사실 주기적으로는 이맘때
 쯤이면 디스크가 한번 터져나와서 최소 걷기 힘든 불편함을 겪을
 시기인데, 이번에는 다양한 원인이 있겠지만(낌새가 오자마자 약부터
 챙겨먹었고, 꾸준히 물리치료 받았고) 매일매일 잠을 푹 잔 것이 꽤 큰
 영향을 미쳤다고 생각한다. 그래도 11시 이전에 잠들어버리면 개인 시간이
 거의 남지 않기에, 매일은 아니더라도 되도록 일찍 자는 생활을
 지속해볼까 한다. 이제 아침에 일찍 깨기만 하면 완벽한 아저씨의
 생활일텐데, 다행인지 불행인지 아침 잠이 많은 것은 도통 변할 생각을
 않는다. 아무튼 나처럼 허리가 안좋은 사람에게는 허리 건강을
 위해서라도, 잠을 많이 자는 것은 중요한 것 같다.</p>]]></content><author><name>sangwoo-joh</name></author><category term="life" /><summary type="html"><![CDATA[나에게는 꾸준히 찾아오는 고통이 있는데 바로 허리 디스크다. 기억 나는 것만 정리해보자면.. 고등학생 시절 모의고사 치다가 1교시 언어 영역 끝나고 디스크 터져서 실려갔던 일을 시작으로… 대학원 시절 데드리프트 하다가 뻑!하고 걷지도 못할 정도로 심하게 터져서 두 세달 정도 고생했던 것과.. 엘리베이터가 고장나서 아들(10kg 이상)을 안고 20층 넘는 계단 오르기를 하다가 급격하게 안좋아져서 일어나지도 못한 것이 가장 최근 일이다.]]></summary></entry><entry><title type="html">나의 Emacs 마크다운 링크 입력기</title><link href="https://sangwoo-joh.github.io/my-emacs-markdown-fill-link" rel="alternate" type="text/html" title="나의 Emacs 마크다운 링크 입력기" /><published>2022-04-07T00:00:00+00:00</published><updated>2022-04-07T00:00:00+00:00</updated><id>https://sangwoo-joh.github.io/my-emacs-markdown-fill-link</id><content type="html" xml:base="https://sangwoo-joh.github.io/my-emacs-markdown-fill-link"><![CDATA[<p>마크다운으로 블로그 글을 정리하면서 자주 마주치는 일 중 하나는 링크를
 입력하는 일이다. 마크다운 문법으로 링크는 다음과 같이 작성할 수 있다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nv">Link Text</span><span class="p">](</span><span class="sx">URL</span><span class="p">)</span>
</code></pre></div></div>

<p>그런데 이 문법으로 내 블로그 안의 글을 링크할 때에는 보통 다음과 같은
 규칙으로 만들고 있다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nv">My Link Text</span><span class="p">](</span><span class="sx">my-link-text</span><span class="p">)</span>
</code></pre></div></div>

<p>즉,</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[]</code> 안의 문자열을 가져와서,</li>
  <li>전부 소문자로 바꾼 다음,</li>
  <li>알파벳 이외의 문자는 전부 <code class="language-plaintext highlighter-rouge">-</code>로 치환한 것,</li>
</ul>

<p>… 을 URL로 사용하고 있다.</p>

<p>이게 한 두개면 그냥 그러려니 하고 직접 타이핑 하겠는데, 글을
 정리하다보니 가짓수가 꽤 많은데다가, 링크 텍스트가 길어지면 URL을
 쓰다가 오타가 나는 경우도 종종 있었다.</p>

<p>그래서 이걸 위한 나만의 마크다운 링크 입력 함수를 이맥스 리슾으로
 작성하기로 했다. 오랜만에 블로그 제목다운 <del>야크</del> 낙타 털 깎기
 작업이다.</p>

<h2 id="만들려는-함수">만들려는 함수</h2>

<p>이맥스에서 함수를 만드는 자세한 내용은 <a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/defun.html">이맥스
 가이드</a>에
 나와있다. 나는 다 읽지는 않았고 적당히 내가 필요한 부분만 골라
 읽었다. 보아하니 <code class="language-plaintext highlighter-rouge">(interactive)</code> 옵션을 줘야 직접 호출할 수 있는 것
 같다. 함수 이름은 적당히 <code class="language-plaintext highlighter-rouge">fill-markdown-link-at-point</code> 로 할
 것이다. 함수 동작은 철저히 나의 유스케이스에 맞춰 작성할 것이다.</p>

<p>함수가 하는 일은 다음과 같다: 커서 근처에서 대괄호 짝을 찾은 다음,
 대괄호 안의 모든 내용을 가져와서 (1) 전부 소문자로 만들고 (2) 알파벳
 외의 글자는 <code class="language-plaintext highlighter-rouge">-</code>로 바꾼 다음 (3) 이 내용을 괄호로 감싸서 대괄호 바로
 뒤에다 붙인다. 간단하지만 아무도 관심이 없어서 직접 만들게 되었다.</p>

<h2 id="의식의-흐름으로-구현하기">의식의 흐름으로 구현하기</h2>

<p>내가 아는 마크다운 문법이 맞는지부터 확인해보자. 나는 보통 링크를
 리스트로 정리하는데, 마크다운에는 다음과 같이 <a href="https://www.markdownguide.org/extended-syntax/#task-lists">작업
 리스트</a>라는
 확장 문법이 있다.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p"> -</span> [ ] TODO
<span class="p"> -</span> [x] DONE!
</code></pre></div></div>

<p>따라서, 정확한 구현은 <code class="language-plaintext highlighter-rouge">[]</code> 안의 문자열을 가져올 때 이게 작업
 체크박스인지를 확인할 필요가 있다. 하지만 이건 내가 직접 해도
 된다. 그러니 함수에서 이걸 체크하지 않고, 내가 직접 원하는 위치의
 링크 텍스트 근처에서 함수를 실행하기로 했다.</p>

<p>이맥스의 내장 함수 목록을 살펴보니, 다음 함수를 사용하면 될 것 같다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">search-forward</code>와 <code class="language-plaintext highlighter-rouge">search-backward</code>: 현재 커서에서 파라미터
문자열이 처음으로 나타나는 곳을 찾고 그 값을 리턴함과 동시에 <strong>해당
위치로 커서를 옮긴다</strong>. 어차피 커서는 내가 링크로 만들고자 하는
대괄호 텍스트 근처에 있을 것이기 때문에, 굳이 정규식으로 검색할
필요는 없어 보인다.</li>
  <li><code class="language-plaintext highlighter-rouge">buffer-substring</code>: <code class="language-plaintext highlighter-rouge">search-*</code> 함수로 찾은 위치는 버퍼에서의
위치(인덱스)이다. 이때 이 함수와 해당 위치로부터 대괄호 안의
문자열을 가져올 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">replace-regexp-in-string</code>: 가져온 문자열에서 알파벳 외의 글자를
전부 <code class="language-plaintext highlighter-rouge">-</code>로 만드는 가장 쉬운 방법은 정규식으로 치환하는 것이다. 마침
딱 맞는 함수가 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">downcase</code>: 문자열 중 대문자를 전부 소문자로 만드는 함수다. 정확히
내가 원하던 것이다.</li>
</ul>

<p>이 내장 함수들을 잘 조합해서 만든 함수는 다음과 같다.</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">fill-markdown-link-at-point</span> <span class="p">()</span>
  <span class="s">"FILL MARKDOWN LINK IN PARENTHESES FROM BRACKET."</span>
  <span class="p">(</span><span class="nv">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">save-excursion</span>
    <span class="p">(</span><span class="k">progn</span>
      <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">start</span> <span class="p">(</span><span class="nv">search-backward</span> <span class="s">"["</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">end</span> <span class="p">(</span><span class="nv">search-forward</span> <span class="s">"]"</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">title</span> <span class="p">(</span><span class="nv">buffer-substring</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">start</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">end</span> <span class="mi">1</span><span class="p">)))</span>
             <span class="p">(</span><span class="nv">title</span> <span class="p">(</span><span class="nv">replace-regexp-in-string</span> <span class="s">"[^a-zA-Z0-9]"</span> <span class="s">"-"</span> <span class="nv">title</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">title</span> <span class="p">(</span><span class="nv">downcase</span> <span class="nv">title</span><span class="p">)))</span>
        <span class="p">(</span><span class="nv">goto-char</span> <span class="p">(</span><span class="nv">match-end</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">insert</span> <span class="p">(</span><span class="nb">format</span> <span class="s">"(%s)"</span> <span class="nv">title</span><span class="p">))</span>
        <span class="p">))))</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">search-*</code> 함수가 직접 커서를 움직인다는 점을 이용해서, 먼저 <code class="language-plaintext highlighter-rouge">[</code>를
찾은 다음 <code class="language-plaintext highlighter-rouge">]</code>를 찾았다. 이렇게 하면 커서가 적당히 대괄호 근처에
있어도 원하는 텍스트를 찾을 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">search-*</code> 함수는 검색 대상 문자열의 위치를 반환하기 때문에, 시작
위치는 한 칸 뒤로 움직여주고 끝 위치는 한 칸 앞으로
움직여준다. 그래야 대괄호를 제외한 온전한 텍스트를 얻는다.</li>
  <li><code class="language-plaintext highlighter-rouge">search-*</code> 함수로 검색을 하고 나면 <code class="language-plaintext highlighter-rouge">(match-beginning)</code>와
<code class="language-plaintext highlighter-rouge">(match-end)</code> 함수를 통해서 매칭된 위치를 알아낼 수 있다. 여기서는
닫힌 대괄호 <code class="language-plaintext highlighter-rouge">]</code>를 찾은 결과가 스택에 남아있고 첫 번째 매칭 위치가
필요해서 <code class="language-plaintext highlighter-rouge">(match-end 0)</code> 으로 간다.</li>
  <li><code class="language-plaintext highlighter-rouge">search-*</code> 함수가 직접 커서를 움직여 버리기 때문에, 실제로 작업이
끝나면 커서는 <code class="language-plaintext highlighter-rouge">insert</code> 한 위치로 간다. 이것은 그다지 기분좋은 일은
아니다. <code class="language-plaintext highlighter-rouge">save-excursion</code> 으로 한번 감싸주면 커서를 얼마든지
움직여도 함수를 실행하기 전 위치로 커서를 복원시켜 준다.</li>
</ul>

<p>원하는 함수를 만들었으니 이제 이 함수를 단축키에 등록하면 된다. 마침
 마크다운 모드를 사용하고 있으므로 해당 모드에만 바인드 시킬 수 있다.</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">use-package</span> <span class="nv">markdown-mode</span>
  <span class="o">....</span>
  <span class="ss">:bind</span>
  <span class="p">(</span><span class="s">"C-c C-c C-l"</span> <span class="o">.</span> <span class="nv">fill-markdown-link-at-point</span><span class="p">))</span>
</code></pre></div></div>

<p>이제 마크다운 파일을 작성하다가 내가 원하는 형태의 링크를 추가하고
 싶으면 단축키로 다음처럼 바로 실행할 수 있다.</p>

<p><img src="https://sangwoo-joh.github.io/assets/img/fill-markdown.gif" alt="fill-markdown" /></p>

<hr />

<p>이렇게 내가 원하는 기능을 이맥스 리습으로 구현해보았다. 코드도 짧고
 읽기 좋아서 만족한다. 이 마지막 구현을 얻기까지 <code class="language-plaintext highlighter-rouge">(message)</code>로 직접
 출력도 해보고 <code class="language-plaintext highlighter-rouge">(debug-on-entry)</code>를 이용해서 스텝 바이 스텝으로
 디버깅도 해보았다. 그러다가 <a href="https://stackoverflow.com/a/11865109">이맥스 정규식 엔진으로는 대괄호 안의
 문자열을 정확하게 못잡는다</a>는
 것을 직접 눈으로 확인하기도 했다. 여태껏 대부분 원하던 기능은 다
 오픈소스로 공개된 패키지가 있어서 그것을 적절히 조합해서
 사용해왔었는데, 이번에 딱 나만의 유스케이스가 생겨서 만들어 보았고
 역시나 야크 털 깎기는 재밌었다. 다음에 또 이런 케이스가 있을지
 모르겠지만 종종 나만의 함수를 만들어볼 기회가 있으면 좋겠다.</p>

<hr />

<p>블로그 글을 쓰고 나서 직접 쓰다보니, 굳이 커서 위치를 원래 위치로
 돌릴 필요가 없다고 느꼈다. 그래서 <a href="https://github.com/sangwoo-joh/dotfiles/commit/0d8755deeee8245ed201472fa31e664866f01a30">커서를 저장하지
 않도록</a>
 수정했다.</p>

<hr />

<p>[<strong>2022/09/05 수정</strong>] 계속 글을 쓰다보니 추가적인 반복 패턴을
 발견할 수 있었다.</p>
<ol>
  <li>위의 기능을 통해 마크다운 문서 링크를 만든다.</li>
  <li><code class="language-plaintext highlighter-rouge">문서 링크.md</code> 파일을 만든다.</li>
  <li>여기에 문서 제목, 문제 아웃링크, 기타 공통 필드를 채운다.</li>
</ol>

<p>여기서 3번의 내용을 템플릿 파일로 만들고, 2번을 할 때 이 템플릿
 파일을 <code class="language-plaintext highlighter-rouge">링크.md</code>로 복사해서 열도록 했다. Elisp에서는 모든 것이
 <em>버퍼</em>에서 수행되는 덕분인지, 1번의 컨텍스트(링크 이름 등)를 그대로
 복사한 파일에 적용할 수 있었다. 추가로 링크 파일로 이동할 때 마커
 스택에 레퍼런스를 추가했더니 인덱스로 돌아오는 것도 한결 편해졌다.</p>

<p>최종 구현은
 <a href="https://github.com/sangwoo-joh/.emacs.d/blob/trunk/lisp/others.el#L7-L114">여기</a>
 에서 볼 수 있다. 참고로 기존에 유지하던 <code class="language-plaintext highlighter-rouge">dotfiles</code>에서 따로
 <code class="language-plaintext highlighter-rouge">.emacs.d</code>로 이맥스 설정만 뺐다. 점점 최적화가 되어 가는 것 같아
 뿌듯하다.</p>]]></content><author><name>sangwoo-joh</name></author><category term="dev" /><summary type="html"><![CDATA[마크다운으로 블로그 글을 정리하면서 자주 마주치는 일 중 하나는 링크를 입력하는 일이다. 마크다운 문법으로 링크는 다음과 같이 작성할 수 있다.]]></summary></entry><entry><title type="html">흰수염고래</title><link href="https://sangwoo-joh.github.io/blue-whale" rel="alternate" type="text/html" title="흰수염고래" /><published>2022-04-05T00:00:00+00:00</published><updated>2022-04-05T00:00:00+00:00</updated><id>https://sangwoo-joh.github.io/blue-whale</id><content type="html" xml:base="https://sangwoo-joh.github.io/blue-whale"><![CDATA[<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Bkv5NIcANyI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

 <br />
 작은 연못에서 시작된 길<br />
 바다로 바다로 갈 수 있음 좋겠네<br />
 어쩌면 그 험한 길에 지칠지 몰라<br />
 걸어도 걸어도 더딘 발걸음에<br />
 <br />

 너 가는 길이 너무 지치고 힘들 때<br />
 말을 해줘 숨기지마 넌 혼자가 아니야<br />
 우리도 언젠가 흰수염고래처럼 헤엄쳐<br />
 두려움 없이 이 넓은 세상 살아 갈 수 있길<br />
 그런 사람이길<br />
 <br />

 더 상처 받지마 이젠 울지마 웃어봐<br />
 <br />

 너 가는 길이 너무 지치고 힘들 때<br />
 말을 해줘 숨기지마 넌 혼자가 아니야<br />
 우리도 언젠가 흰수염고래처럼 헤엄쳐<br />
 두려움 없이 이 넓은 세상 살아 갈 수 있길<br />
 그런 사람이길<br />
 <br />

 너 가는 길이 너무 지치고 힘들 때<br />
 말을 해줘 숨기지마 넌 혼자가 아니야<br />
 우리도 언젠가 흰수염고래처럼 헤엄쳐<br />
 두려움 없이 이 넓은 세상 살아 갈 수 있길<br />
 그런 사람이길<br />
</center>

<hr />

<center>
 가사가 너무 좋아서 기록해본다.
</center>]]></content><author><name>sangwoo-joh</name></author><category term="life" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Emacs Native Compliation</title><link href="https://sangwoo-joh.github.io/official-emacs-native-comp" rel="alternate" type="text/html" title="Emacs Native Compliation" /><published>2022-03-18T00:00:00+00:00</published><updated>2022-03-18T00:00:00+00:00</updated><id>https://sangwoo-joh.github.io/official-emacs-native-comp</id><content type="html" xml:base="https://sangwoo-joh.github.io/official-emacs-native-comp"><![CDATA[<p>몰랐는데 Andrea Corallo 님께서 작업하신 이맥스 native compilation
 브랜치가 <a href="https://www.reddit.com/r/emacs/comments/myej3z/the_nativecompilation_branch_was_just_merged_into/">master 브랜치에 머지되었다는
 소식</a>을
 보았다. GNU 로그를 보니
 <a href="https://git.savannah.gnu.org/gitweb/?p=emacs.git;a=commit;h=289000eee729689b0cf362a21baa40ac7f9506f6">진짜</a>다. 당장 써보자.</p>

<p>일단 <code class="language-plaintext highlighter-rouge">configure</code> 옵션이 <a href="emacs-native-comp">기존 feature 브랜치</a>와 좀
 달라졌다: <code class="language-plaintext highlighter-rouge">./configure --with-native-compilation</code> 을 해야
 한다. 나머지는 똑같다. GCC-10과 libgccjit 디펜던시를 설치하고 CC와
 CXX를 적절하게 설정해둔 뒤 <code class="language-plaintext highlighter-rouge">./autogen.sh</code> 후 <code class="language-plaintext highlighter-rouge">./configure
 --with-native-compilation</code> 하고 빌드하면 된다. 그런데 <code class="language-plaintext highlighter-rouge">master</code>
 브랜치를 곧바로 시도했더니 빌드 실패가 뜬다(?). 아마 다른 기능들까지
 반영되어서 내 로컬에서는 빌드가 깨지는 듯 하다. 침착히 찾아보니
 <code class="language-plaintext highlighter-rouge">emacs-28.0.50</code> 기준으로 반영이 된 것 같다. <code class="language-plaintext highlighter-rouge">tag</code>를 보니
 <code class="language-plaintext highlighter-rouge">emacs-28.0.90</code>, <code class="language-plaintext highlighter-rouge">emacs-28.0.91</code>, <code class="language-plaintext highlighter-rouge">emacs-28.0.92</code>가
 있었다. 흐음. <code class="language-plaintext highlighter-rouge">emacs-28.0.92</code>를 빌드 시도해보았다. 안된다. <code class="language-plaintext highlighter-rouge">make</code>로
 병럴 작업 없이 시도해보았다. 안된다. <code class="language-plaintext highlighter-rouge">emacs-28.0.90</code>으로
 시도해보았다. <code class="language-plaintext highlighter-rouge">make -j5</code>로 잡을 5개나 주었는데 대략 8분정도 걸려서
 빌드에 성공하였다.</p>

<p>빌드 후 인스톨해서 켜보니 예상과는 다르게 엄청나게 오랜 시간 동안
 로딩을 진행하였다. 뭐 때문인지 <code class="language-plaintext highlighter-rouge">htop</code>으로 작업을 살펴보니 기존에
 빌드해둔 <code class="language-plaintext highlighter-rouge">eln</code> 들을 싹 무시하고 처음부터 새로 다시 빌드하고
 있었다. 그럴 수 있지. 적절한 시간이 흐르고 네이티브 컴파일레이션이
 끝나고 나니 다시 원래의 이맥스로 돌아왔다. 이미 네이티브를 쓰고
 있어서 크게 체감은 안되지만, 정식으로 메인 브랜치에 반영되었으니 이제
 안심하고 써도 되겠다. 레딧 댓글을 보니 28 공식 버전에는 디폴트로
 네이티브가 들어간다고 하는데 기대된다.</p>]]></content><author><name>sangwoo-joh</name></author><category term="dev" /><summary type="html"><![CDATA[몰랐는데 Andrea Corallo 님께서 작업하신 이맥스 native compilation 브랜치가 master 브랜치에 머지되었다는 소식을 보았다. GNU 로그를 보니 진짜다. 당장 써보자.]]></summary></entry><entry><title type="html">파이썬 데코레이터</title><link href="https://sangwoo-joh.github.io/python-decorators" rel="alternate" type="text/html" title="파이썬 데코레이터" /><published>2022-02-24T00:00:00+00:00</published><updated>2022-02-24T00:00:00+00:00</updated><id>https://sangwoo-joh.github.io/python-decorators</id><content type="html" xml:base="https://sangwoo-joh.github.io/python-decorators"><![CDATA[<p>요즘 파이썬으로 다양한 작업을 하고 있다. 덕분에 동적 타이핑
 세계에서만 해볼 수 있는 다양한 짓(?)을 해보고 있는데, 그 중에서도
 데코레이터를 유용하게 썼던 경험을 소개해본다.</p>

<h2 id="파이썬-데코레이터">파이썬 데코레이터</h2>
<p>데코레이터의 생긴 모습 자체는 익숙하다. 자바에도
 <a href="https://en.wikipedia.org/wiki/Java_annotation">어노테이션</a>이라는게
 있긴 한데, 얘는 정적인 용도로 컴파일 타임에 주로 쓰이는 것으로 알고
 있다. 반면 파이썬의 데코레이터는 동적인 환경에서 온갖 다양한 훅을
 구사할 수 있다. 생긴 모습은 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">@</code>로 시작하는 부분이 함수에 씌여진 데코레이터이다. 적용된 함수의
 <strong>모든 것</strong>을 동적으로 후킹할 수 있는데, 예를 들면</p>
<ul>
  <li>함수가 속한 클래스, 함수 이름</li>
  <li>args와 kwargs를 포함한 모든 함수 아규먼트들</li>
  <li>아예 함수 자체를 호출하지 않거나 두 번 이상 호출할 수도 있다.</li>
</ul>

<p>그러니까 함수의 행동을 동적으로 조작하고 싶을 때 유용한 것으로
 이해했다.</p>

<p>모든 것이 오브젝트로 관리되는 파이썬 세계에서 사실 데코레이터 역시
 <a href="https://www.python.org/dev/peps/pep-0318/#motivation">그냥
 함수</a>다. 그러니까
 위의 코드는 사실 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func_to_wrap</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">func_to_wrap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">closure</span>

<span class="c1"># apply decorator
</span><span class="n">foo</span> <span class="o">=</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</code></pre></div></div>

<p>함수도 오브젝트이므로 파라미터로 넘길 수 있는데(functional?!), 이를
 받아서 원래 함수와 원래 아규먼트를 가지고 다양한 짓을 하는
 클로저(<code class="language-plaintext highlighter-rouge">closure</code>)를 만들어서 리턴하는 함수가 바로
 데코레이터다. 여기서는 그냥 원래 함수를 원래 아규먼트로
 호출했다. <code class="language-plaintext highlighter-rouge">@decorator</code>는 데코레이터를 감싸서 만든 클로저 <code class="language-plaintext highlighter-rouge">foo =
 decorator(foo)</code>를 좀더 읽기 좋게 만들어주는 Syntactic Sugar다.</p>

<p>코드를 보면 알겠지만 <code class="language-plaintext highlighter-rouge">foo</code>에 넘어가는 모든 파라미터들을
 <code class="language-plaintext highlighter-rouge">closure(*args, **kwargs)</code>로 후킹하고 있기 때문에 우리는 이 모든
 파라미터들에 접근할 수 있게 된다.</p>

<h2 id="functoolswraps"><code class="language-plaintext highlighter-rouge">functools.wraps</code></h2>
<p>다만 위와 같이 클로저를 만들어 버리면 한 가지 문제가 생긴다. 원본
 함수 <code class="language-plaintext highlighter-rouge">foo</code>를 받아서 이걸 클로저로 덮어 쓴 함수 오브젝트를 리턴하기
 때문에, 데코레이팅된 <code class="language-plaintext highlighter-rouge">foo</code> 함수 오브젝트를 <code class="language-plaintext highlighter-rouge">print</code>로 찍어보면 이름이
 <code class="language-plaintext highlighter-rouge">foo</code>가 아니라 <code class="language-plaintext highlighter-rouge">closure</code>가 나온다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">function</span> <span class="n">decorator</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">closure</span> <span class="n">at</span> <span class="p">....</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>생각해보면 당연하다. 우리는 원본 <code class="language-plaintext highlighter-rouge">foo</code> 함수를 돌려준게 아니기
 때문이다. 앞에서 모든 것을 후킹할 수 있다고 했는데, 이러면 함수
 이름이나 함수가 속한 클래스를 못찾게 된다. 여기서는 함수 이름을
 예시로 들었지만, 실제로는 원본 함수 오브젝트의 모든 함수 관련
 속성(function attribute), 즉 <code class="language-plaintext highlighter-rouge">__name__</code>, <code class="language-plaintext highlighter-rouge">__dict__</code>, <code class="language-plaintext highlighter-rouge">__qualname__</code>,
 <code class="language-plaintext highlighter-rouge">__code__</code>, <code class="language-plaintext highlighter-rouge">__module__</code>, <code class="language-plaintext highlighter-rouge">__doc__</code> 등을 잃어버리게 된다.</p>

<p>이 문제를 해결해주는 아이가 바로 <code class="language-plaintext highlighter-rouge">functools.wraps</code>이다. 얘는 표준
 라이브러리에 있으니까 맘 편히 쓰면 된다. 사용 방법은 위의 데코레이터
 정의에 다음 한 줄을 추가해주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">functools</span>

<span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func_to_wrap</span><span class="p">):</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func_to_wrap</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">func_to_wrap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">closure</span>
</code></pre></div></div>

<p>한마디로 정확한 데코레이터를 만들기 위한 데코레이터다. 뭔가 점점
 게슈탈트 붕괴가 일어나는 듯 하다. 아무튼 얘는 파라미터로 받은 원본
 함수 오브젝트의 모든 메타데이터를 유지해준다. 구체적으로는
 <code class="language-plaintext highlighter-rouge">update_wrapper</code>와 <code class="language-plaintext highlighter-rouge">parital</code> 등 깊은 내부 구현 사항이 있는데 거기까지
 알아야 할 일은 없을 것 같아서 이쯤에서 멈추겠다.</p>

<p>아무튼 <strong>데코레이터를 만들 때는 <code class="language-plaintext highlighter-rouge">functools.wraps</code>로 원본 함수를 한번
 감싸 줘야 함수 속성이 유지된다</strong>는 것만 기억하면 된다.</p>

<h2 id="유용하게-썼던-데코레이터">유용하게 썼던 데코레이터</h2>
<h3 id="타이머">타이머</h3>
<p>먼저 타이머다. 이름 그대로 함수에 타이머를 달아서 수행 시간을 측정할
 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="n">functools</span>

<span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">started</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">finished</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">time_spent</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="nf">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="p">(</span><span class="n">finished</span> <span class="o">-</span> <span class="n">started</span><span class="p">))</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__qualname__</span><span class="si">}</span><span class="s"> took </span><span class="si">{</span><span class="n">time_spent</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">return</span> <span class="n">closure</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">time.time()</code>으로 원본 함수 전후에 틱을 잰다. 단위는 초(second)다.</li>
  <li><code class="language-plaintext highlighter-rouge">datetime.timedelta()</code>로 시간 간격을 읽기 좋은 형태로 바꿔서
출력한다.</li>
  <li><code class="language-plaintext highlighter-rouge">__qualname__</code> 속성으로 수행한 함수 이름(메소드라면 클래스
이름까지) 같이 보여주면 좋다.</li>
  <li>참고로 <code class="language-plaintext highlighter-rouge">*args</code>에 <code class="language-plaintext highlighter-rouge">self</code>까지 같이 넘어오기 때문에, 이거 하나로 일반
함수 및 클래스의 메소드까지 다 적용할 수 있다.</li>
</ul>

<p>여기서 좀더 나가면 <code class="language-plaintext highlighter-rouge">*args</code> 또는 <code class="language-plaintext highlighter-rouge">**kwargs</code>에 특정 타입의 오브젝트가
 넘어온다고 가정하고, 해당 오브젝트의 특정 필드에 함수 수행 시간을
 기록할 수도 있다. 나는 보통 장고의 ORM 오브젝트를 넘겨서
 <code class="language-plaintext highlighter-rouge">time_spent</code>를 저장하기도 했다.</p>

<h3 id="예외-삼키기">예외 삼키기</h3>
<p>많은 API를 호출해서 결과 페이로드를 파싱해야 할 때가 있다. 그런데
 오래 서비스된 API라서 페이로드의 모양이 일정하지 않은 경우가 종종
 있다. 즉, 서버의 버전이 업그레이드되면서 Json의 특정 필드가 <code class="language-plaintext highlighter-rouge">null</code> 인
 경우가 생기는 것이다. 이런 코너 케이스를 모두 일일이 찾아서 그에
 해당하는 디폴트 값을 줘도 되지만, 단순하게 특정 필드가 <code class="language-plaintext highlighter-rouge">null</code>인
 경우를 아예 무시해도 좋은 경우라면 그냥 예외를 삼켜버리면 된다. 보통
 다음 예외가 발생한다:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">TypeError</code>: <code class="language-plaintext highlighter-rouge">null</code> 오브젝트에 인덱스로 접근할 때 발생한다. 즉
<code class="language-plaintext highlighter-rouge">None[1]</code>에서 발생한다.</li>
  <li><code class="language-plaintext highlighter-rouge">KeyError</code>: 오브젝트 자체는 <code class="language-plaintext highlighter-rouge">null</code>이 아니지만 키 값이 없을 때
발생한다. 즉 <code class="language-plaintext highlighter-rouge">{'a': 1}['b']</code>에서 발생한다.</li>
  <li><code class="language-plaintext highlighter-rouge">AttributeError</code>: 속성 자체가 없을 때 발생한다. 예를 들어 어떤
클래스의 인스턴스 <code class="language-plaintext highlighter-rouge">foo</code>에 <code class="language-plaintext highlighter-rouge">foo.a</code>는 있는데 <code class="language-plaintext highlighter-rouge">foo.b</code>는 없으면
발생한다.</li>
</ul>

<p>사실 모든 예외를 싸그리 <code class="language-plaintext highlighter-rouge">Exception</code>으로 잡아서 무시해도 되지만,
 그러면 다른 오류가 난 경우까지 삼켜버리기 때문에 나중에 괴상한 오류를
 만날 수도 있으니 주의해야 한다. 아무튼 이렇게 집어 삼킬 예외를
 정의하고 나면 다음과 같은 데코레이터를 사용할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">functools</span>

<span class="k">def</span> <span class="nf">swallow_exception</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nf">except </span><span class="p">(</span><span class="nb">TypeError</span><span class="p">,</span> <span class="nb">KeyError</span><span class="p">,</span> <span class="nb">AttributeError</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">return</span> <span class="n">closure</span>
</code></pre></div></div>

<p>별거 없이 <code class="language-plaintext highlighter-rouge">try ... except</code>로 한번 감싸서 원하는 예외만 삼키는
 구조인데, 내가 겪은 것처럼 예외가 여기저기 발생할 수 있어서 여기저기
 <code class="language-plaintext highlighter-rouge">try</code>를 삽입하기 귀찮을 때 유용하게 쓸 수 있다.</p>

<h2 id="데코레이터-적용-순서">데코레이터 적용 순서</h2>
<p>앞에서 데코레이터는 그냥 클로저를 리턴하는 함수라고 했는데, 따라서
 당연히 하나의 함수에 여러 개의 데코레이터를 적용하는 것도
 가능하다. 그리고 파이썬 표준에서는 이렇게 여러 개의 데코레이터가
 적용됐을 때 <a href="https://mail.python.org/pipermail/python-dev/2004-September/048874.html">어떤 순서로
 적용되는지</a>를
 명시하고 있는데, 한마디로 <strong>함수에 가까운 것부터 먼저
 적용</strong>된다. 코드를 위아래로 훑는다고 생각하면 일종의 스택이라고
 생각해도 되겠다. 맨 마지막(아래) 데코레이터부터 적용되니까.</p>

<p>아래와 같이 위의 두 가지 데코레이터를 두 가지 순서로 적용한 경우를
 모두 살펴보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># swallow_exception -&gt; timer
</span><span class="nd">@timer</span>
<span class="nd">@swallow_exception</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="k">raise</span> <span class="nb">TypeError</span>


<span class="c1"># timer -&gt; swallow_exception
</span><span class="nd">@swallow_exception</span>
<span class="nd">@timer</span>
<span class="k">def</span> <span class="nf">baz</span><span class="p">():</span>
    <span class="k">raise</span> <span class="nb">TypeError</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bar()</code>를 호출하면 <code class="language-plaintext highlighter-rouge">@swallow_exception</code>가 먼저 예외를 삼키고, 그
다음 <code class="language-plaintext highlighter-rouge">@timer</code>가 앞선 모든 동작의 시간을 계산하여 출력한다.</li>
  <li>반면 <code class="language-plaintext highlighter-rouge">baz()</code>를 호출하면 <code class="language-plaintext highlighter-rouge">@timer</code>가 먼저 적용되는데, 예외가 발생하여
시간 계산을 끝내지 못하고 예외를 던져버린다. 그러면
<code class="language-plaintext highlighter-rouge">@swallow_exception</code>이 던져진 예외를 삼키게 되고 결과적으로 아무런
출력이 없다.</li>
</ul>

<hr />

<p>정적 타입과 함수형 프로그래밍 지지자로서 파이썬 관련 글은 피하고
 싶었지만, 파이썬으로 밥 벌어 먹고 살다 보니 이쪽의 경험이 유의미하게
 늘어나고 있고 개중에는 또 재밌고 유용한 것도 있어서 이렇게 기록을
 남기게 되었다. 기왕 이렇게 된 거 종종 파이썬 관련 글도 써봐야겠다.</p>]]></content><author><name>sangwoo-joh</name></author><category term="dev" /><category term="python" /><summary type="html"><![CDATA[요즘 파이썬으로 다양한 작업을 하고 있다. 덕분에 동적 타이핑 세계에서만 해볼 수 있는 다양한 짓(?)을 해보고 있는데, 그 중에서도 데코레이터를 유용하게 썼던 경험을 소개해본다.]]></summary></entry></feed>