<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-site-verification" content="fgTBOMeN_sdI4JNBqYTzDwH0458H8AAVbF78jLjwudg" />
  <script type="text/javascript" src="/assets/vendor/moment.min.js"></script>
  <script type="text/javascript" src="/assets/js/site.js"></script>
  <!-- <script src="https://unpkg.com/cursor-effects@latest/dist/browser.js"></script> -->

  <title>
    
      OCaml로 PS 하기 -4-
    
  </title>

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="OCaml로 PS 하기 -4-" />
<meta name="author" content="sangwoo-joh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="최애 언어 OCaml 로 문제를 풀어보자 네 번째 시리즈다." />
<meta property="og:description" content="최애 언어 OCaml 로 문제를 풀어보자 네 번째 시리즈다." />
<link rel="canonical" href="https://sangwoo-joh.github.io/ocaml-ps-sums-of-powers" />
<meta property="og:url" content="https://sangwoo-joh.github.io/ocaml-ps-sums-of-powers" />
<meta property="og:site_name" content="Caml Shaving" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-13T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="OCaml로 PS 하기 -4-" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sangwoo-joh"},"dateModified":"2020-04-13T00:00:00+00:00","datePublished":"2020-04-13T00:00:00+00:00","description":"최애 언어 OCaml 로 문제를 풀어보자 네 번째 시리즈다.","headline":"OCaml로 PS 하기 -4-","mainEntityOfPage":{"@type":"WebPage","@id":"https://sangwoo-joh.github.io/ocaml-ps-sums-of-powers"},"url":"https://sangwoo-joh.github.io/ocaml-ps-sums-of-powers"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="https://sangwoo-joh.github.io/feed.xml" title="Caml Shaving" />

  <link rel="apple-touch-icon" sizes="57x57" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="https://sangwoo-joh.github.io/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://sangwoo-joh.github.io/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="https://sangwoo-joh.github.io/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://sangwoo-joh.github.io/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="https://sangwoo-joh.github.io/assets/icons/manifest.json">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Ubuntu" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Open+Sans" />
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <link rel="stylesheet" href="https://sangwoo-joh.github.io/assets/css/main.css" />
  <link rel="stylesheet" href="https://sangwoo-joh.github.io/assets/css/syntax.css" />
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J0C68FHJ6L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J0C68FHJ6L');
</script>


</head>
<body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="https://sangwoo-joh.github.io">/home/caml-shaving</a>
<center>
<h1>OCaml로 PS 하기 -4-</h1>
<h2>Permutation, Combination</h2>
</center>

<div class="post-edit-date">
  
  2020-04-13
</div>

<div class="post-edit-date">
  
  
</div>

<em><p align="right">

태그:



<a href="/archive?tag=dev"><span class="tag">dev</span></a>





<a href="/archive?tag=ocaml"><span class="tag">ocaml</span></a>




</p></em>


<p>최애 언어 <a href="https://ocaml.org/">OCaml</a> 로 문제를 풀어보자 네 번째
 시리즈다.</p>

<h4 id="근황">근황</h4>
<p>4개월 만의 포스팅이다. 그 사이에 아버지가 되면서 눈코 뜰 새 없이
 너무나도 바빠져서, 문제를 꽤나 많이 풀었음에도 포스팅은 하지
 못했다. 육아가 힘들다는 말만 들었지 실제로 겪어보니 정말 차원이
 다르다. 이제 아들이 자는 틈을 타서 짬짬이 코딩 해야겠다. 크흑.</p>

<h3 id="the-sums-of-powers"><a href="https://www.hackerrank.com/challenges/functional-programming-the-sums-of-powers/problem">The Sums of Powers</a></h3>
<p>문제풀이 사이트를 백준에서 <a href="https://www.hackerrank.com">해커 랭크</a>로
 바꿔보았다. 무려 “함수형 프로그래밍” 이라는 테마가 따로 있는 것이
 너무 마음에 들었다.</p>

<p>이 문제는 입력으로 정수 \(1 \leq X \leq 1000\)와 \(2 \leq N \leq
 10\)을 받아서, \(\displaystyle \sum_{x \in S} {x ^ N} = X\) 를
 만족하는 집합 \(S\)의 개수를 세는 문제이다. 조금 더 일반화하면,
 가능한 모든 조합을 탐색해서 조건을 만족하는 경우를 세면 된다. 이렇게
 조합을 탐색하는 알고리즘을 수도 코드로 나타내면 대충 다음과 같을
 것이다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">pick</span> <span class="n">picked</span> <span class="o">=</span>
  <span class="k">if</span> <span class="nc">P</span><span class="p">(</span><span class="n">picked</span><span class="p">)</span> <span class="k">then</span> <span class="c">(* base case *)</span>
  <span class="k">else</span>
    <span class="k">let</span> <span class="n">smallest</span> <span class="o">=</span> <span class="c">(* possible smallest element *)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">maximum</span> <span class="o">=</span> <span class="c">(* possible maximum element *)</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">smallest</span> <span class="k">to</span> <span class="n">maximum</span> <span class="k">do</span>
      <span class="nn">Stack</span><span class="p">.</span><span class="n">push</span> <span class="n">i</span> <span class="n">picked</span><span class="p">;</span>
      <span class="n">pick</span> <span class="n">picked</span><span class="p">;</span>
      <span class="nn">Stack</span><span class="p">.</span><span class="n">pop</span> <span class="n">picked</span>
    <span class="k">done</span>
</code></pre></div></div>
<p>이때까지 고른 조합 <code class="language-plaintext highlighter-rouge">picked</code> 는 가장 단순하게는 스택을 이용할 수 있다.</p>

<p>Base case는 이때까지 고른 <code class="language-plaintext highlighter-rouge">picked</code> 조합을 검사하여 재귀를 끝내야
 하는지를 판단한다. 대부분의 문제에서는 “n 개를 조합했을 때 …” 와
 같이 명시적인 개수가 주어지지만, 이 문제에서는 앞서 말한 조건인
 \(\displaystyle \sum_{x \in S} {x ^ N} = X\) 가 된다.</p>

<p>이제 이걸 마음에 두고 문제를 풀어보자. 일단 \(x^N\)을 계산하는 함수는
 다음과 같다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">power</span> <span class="n">x</span> <span class="n">n</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="n">power</span> <span class="n">x</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>사실 이분 탐색으로 더 빠르게 동작하는 함수를 만들 수도 있지만, \(N
 \leq 10\) 이라는 조건이 있으므로 이 문제에서는 이정도로 충분하다.</p>

<p>다음은 실제 \(X\)와 \(N\)을 받아서 개수를 세는 함수를
 짜보자. OCaml에서 대문자로 시작하는 모든 변수는 모듈로 인식되므로
 사용할 변수를 소문자로 썼다.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">solve</span> <span class="n">x</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">max</span> <span class="o">=</span> <span class="n">int_of_float</span> <span class="p">(</span><span class="n">sqrt</span> <span class="p">(</span><span class="n">float_of_int</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">picked</span> <span class="o">=</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">create</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">pick</span> <span class="n">picked</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">fold</span> <span class="p">(</span><span class="k">fun</span> <span class="n">acc</span> <span class="n">elt</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">power</span> <span class="n">elt</span> <span class="n">n</span><span class="p">)</span> <span class="mi">0</span> <span class="n">picked</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="k">then</span> <span class="n">incr</span> <span class="n">cnt</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">sum</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="k">then</span>
      <span class="k">let</span> <span class="n">smallest</span> <span class="o">=</span>
        <span class="k">if</span> <span class="nn">Stack</span><span class="p">.</span><span class="n">is_empty</span> <span class="n">picked</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">succ</span> <span class="p">(</span><span class="nn">Stack</span><span class="p">.</span><span class="n">top</span> <span class="n">picked</span><span class="p">)</span>
      <span class="k">in</span>
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">smallest</span> <span class="k">to</span> <span class="n">max</span> <span class="k">do</span>
        <span class="nn">Stack</span><span class="p">.</span><span class="n">push</span> <span class="n">i</span> <span class="n">picked</span><span class="p">;</span>
        <span class="n">pick</span> <span class="n">picked</span><span class="p">;</span>
        <span class="n">ignore</span> <span class="p">(</span><span class="nn">Stack</span><span class="p">.</span><span class="n">pop</span> <span class="n">picked</span><span class="p">)</span>
      <span class="k">done</span>
  <span class="k">in</span>
  <span class="n">pick</span> <span class="n">picked</span><span class="p">;</span>
  <span class="o">!</span><span class="n">cnt</span>
</code></pre></div></div>

<p>일단 고를 수 있는 가장 큰 값은 \(X^{1/N}\)임을 쉽게 알 수
  있다. 정확하게 이 값을 구해도 되지만 적당히 \(\sqrt{X}\)까지 구해도
  괜찮을 것이다.</p>

<p>핵심은 실제 조합을 만들고 탐색하는 재귀함수 <code class="language-plaintext highlighter-rouge">pick</code> 이다. 우선,
  지금까지 만든 조합 <code class="language-plaintext highlighter-rouge">picked</code>에 대해서 모든 \(N\)승 합 <code class="language-plaintext highlighter-rouge">sum</code>을
  구한다. 그리고 이 합이 \(X\)와 같으면 개수를 증가시킨다. 그렇지않고
  이 합이 여전히 \(X\)보다 작은 경우, 아직까지 더 탐색할 여지가
  있으므로 그때 탐색한다. 이 부분이 작은 최적화다.</p>

<p>고를 수 있는 가장 값은 1이고, 이건 아직까지 만든 조합이 없을
  때이다. 만약 하나라도 만든 조합이 있다면, 고를 수 있는 가장 작은
  값은 만든 조합 중 가장 큰 값보다 1 큰값이다. 그 후 고를 수 있는 값의
  범위 (가장 작은 값부터 가장 큰 값) 에 대해서 하나씩 조합을
  만들어보고, 다시 이 조합에 대해서 탐색을 한 뒤, 바로 직전에 탐색한
  값을 조합에서 빼는 방식으로 모든 탐색 공간을 훑어보면 된다.</p>

<p>이 문제는 모든 조합 공간을 어떻게 만들지만 고민하면 쉽게 풀리는
  문제다. 까다로운 점은 Base Case 를 주어진 조건에 맞게 “이때까지 만든
  조합의 \(N\) 승의 합”을 구한 뒤 확인해야 하는 점과, 이 합이 이미
  \(X\)를 넘긴 경우는 탐색하지 않아도 된다는 점이다. 이 두 가지만 잘
  처리하면 쉽게 풀 수 있다.</p>

<p>아쉽게도 해커랭크에서는 제출한 코드의 실행 시간이나 순위가 나오진
  않고, 단순히 테스트 케이스를 다 통과했는지 여부만 나온다. 그래도
  무려 “함수형 프로그래밍” 섹션이 있다는 점에 의의를 두자.</p>

<h4 id="예고">예고</h4>
<p>다음은 OCamlgraph를 흉내내서 그래프 문제를 풀어볼 예정이다.</p>


<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<br />

<div>
  <script src="https://giscus.app/client.js"
          data-repo="sangwoo-joh/reactions"
          data-repo-id="R_kgDOJFNVQw"
          data-category="Comments"
          data-category-id="DIC_kwDOJFNVQ84CUox9"
          data-mapping="pathname"
          data-strict="1"
          data-reactions-enabled="1"
          data-emit-metadata="0"
          data-input-position="bottom"
          data-theme="light_high_contrast"
          data-lang="ko"
          data-loading="lazy"
          crossorigin="anonymous"
          async>
  </script>
</div>

<br />

      </div>
    </main>

    
    <footer>
  <a href="/feed.xml">rss</a>
  <a href="mailto:work.sangwoo.joh@gmail.com">mail</a>
  <a href="https://www.linkedin.com/in/sangwoo-joh">linkedin</a>
  <a href="https://github.com/sangwoo-joh">github</a>
  <p class="copyright text-muted">Copyright &copy; sangwoo-joh 2023</p>
  <small><a target="_blank" href="https://icons8.com/icons/set/--camel">Camel icon</a> icon by <a target="_blank" href="https://icons8.com">Icons8</a></small>
</footer>

  </body>
</html>
