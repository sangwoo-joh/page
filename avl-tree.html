<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-site-verification" content="fgTBOMeN_sdI4JNBqYTzDwH0458H8AAVbF78jLjwudg" />
  <script type="text/javascript" src="/assets/vendor/moment.min.js"></script>
  <script type="text/javascript" src="/assets/js/site.js"></script>
  <!-- <script src="https://unpkg.com/cursor-effects@latest/dist/browser.js"></script> -->

  <title>
    
      AVL 트리 정-복하기
    
  </title>

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="AVL 트리 정-복하기" />
<meta name="author" content="sangwoo-joh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Binary Search Tree AVL 트리를 이해하기 위해서는 BST를 먼저 알아야 한다. BST는 다음 세 가지를 만족하는 그래프이다. Tree: Cycle이 없다. Binary: 자식이 최대 두개이다. 따라서 자식 노드를 left, right로 구분한다. Search Property: 모든 서브트리에 대해서 검색 성질을 만족한다. 검색 성질이란 모든 노드에 대해서 node-&gt;left &lt; node &lt; node-&gt;right 의 순서(order)를 만족하는 것을 말한다." />
<meta property="og:description" content="Binary Search Tree AVL 트리를 이해하기 위해서는 BST를 먼저 알아야 한다. BST는 다음 세 가지를 만족하는 그래프이다. Tree: Cycle이 없다. Binary: 자식이 최대 두개이다. 따라서 자식 노드를 left, right로 구분한다. Search Property: 모든 서브트리에 대해서 검색 성질을 만족한다. 검색 성질이란 모든 노드에 대해서 node-&gt;left &lt; node &lt; node-&gt;right 의 순서(order)를 만족하는 것을 말한다." />
<link rel="canonical" href="https://sangwoo-joh.github.io/avl-tree" />
<meta property="og:url" content="https://sangwoo-joh.github.io/avl-tree" />
<meta property="og:site_name" content="Caml Shaving" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-07-08T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="AVL 트리 정-복하기" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sangwoo-joh"},"dateModified":"2018-07-08T00:00:00+00:00","datePublished":"2018-07-08T00:00:00+00:00","description":"Binary Search Tree AVL 트리를 이해하기 위해서는 BST를 먼저 알아야 한다. BST는 다음 세 가지를 만족하는 그래프이다. Tree: Cycle이 없다. Binary: 자식이 최대 두개이다. 따라서 자식 노드를 left, right로 구분한다. Search Property: 모든 서브트리에 대해서 검색 성질을 만족한다. 검색 성질이란 모든 노드에 대해서 node-&gt;left &lt; node &lt; node-&gt;right 의 순서(order)를 만족하는 것을 말한다.","headline":"AVL 트리 정-복하기","mainEntityOfPage":{"@type":"WebPage","@id":"https://sangwoo-joh.github.io/avl-tree"},"url":"https://sangwoo-joh.github.io/avl-tree"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="https://sangwoo-joh.github.io/feed.xml" title="Caml Shaving" />

  <link rel="apple-touch-icon" sizes="57x57" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="https://sangwoo-joh.github.io/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://sangwoo-joh.github.io/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="https://sangwoo-joh.github.io/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://sangwoo-joh.github.io/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="https://sangwoo-joh.github.io/assets/icons/manifest.json">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Ubuntu" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Open+Sans" />
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <link rel="stylesheet" href="https://sangwoo-joh.github.io/assets/css/main.css" />
  <link rel="stylesheet" href="https://sangwoo-joh.github.io/assets/css/syntax.css" />
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J0C68FHJ6L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J0C68FHJ6L');
</script>


</head>
<body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="https://sangwoo-joh.github.io">/home/caml-shaving</a>
<center>
<h1>AVL 트리 정-복하기</h1>
<h2>스스로 균형 잡는 친구</h2>
</center>

<div class="post-edit-date">
  
  <div class="post-date">(First release)  </div>
  
  2018-07-08
</div>

<div class="post-edit-date">
  
  <div class="post-date">(Last update) </div>
  
  2023-10-31 23:44
</div>

<em><p align="right">

태그:



<a href="/archive?tag=dev"><span class="tag">dev</span></a>




</p></em>


<h2 id="binary-search-tree">Binary Search Tree</h2>
<p>AVL 트리를 이해하기 위해서는 BST를 먼저 알아야 한다. BST는 다음 세 가지를
 만족하는 그래프이다.</p>
<ol>
  <li>Tree: Cycle이 없다.</li>
  <li>Binary: 자식이 최대 두개이다. 따라서 자식 노드를 left, right로 구분한다.</li>
  <li>Search Property: 모든 서브트리에 대해서 검색 성질을 만족한다. 검색 성질이란
모든 노드에 대해서 <code class="language-plaintext highlighter-rouge">node-&gt;left &lt; node &lt; node-&gt;right</code> 의 순서(order)를
만족하는 것을 말한다.</li>
</ol>

<p>이 세 가지 조건을 만족하는 데이터 구조를 BST라고 한다. 여기서는 문제 풀이
 수준에서 써먹을 수 있는 AVL 트리를 만들어 볼 것이다.</p>

<h3 id="기본-구조">기본 구조</h3>
<p>BST의 기본 구조는 다음과 같다.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>      <span class="c1">// id</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>  <span class="c1">// left child</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span> <span class="c1">// right child</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="search">Search</h3>
<p>검색 함수는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// not found</span>

  <span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>BST의 모든 노드가 검색 성질을 만족하기 때문에, 현재 방문한 노드를 기준으로 키
 값을 비교하여 다음에 방문할 노드를 알 수 있다. 따라서 ‘균형 잡힌’ BST에서 최대
 방문 횟수는 루트로부터 시작하는 longest path의 길이 (=height)가 되므로 복잡도는
 <code class="language-plaintext highlighter-rouge">O(log N)</code>이 된다.</p>

<h3 id="insert">Insert</h3>
<p>BST에 노드를 추가하는 작업은 검색과 비슷하다. 루트 노드에서부터 노드가 삽입될
 적절한 위치를 찾는다. 만약에 이미 삽입할 노드가 존재한다면, 즉 키 값에 해당하는
 노드가 이미 있으면, 알아서 적절히 처리하면 된다. 이미 있는 노드를 그냥 냅두면
 집합 자료구조인 <code class="language-plaintext highlighter-rouge">Set</code>이 되고, 같은 키를 갖는 노드의 개수를 센다면 <code class="language-plaintext highlighter-rouge">MultiSet</code>과 같은
 자료구조가 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">insert</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gen_node</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">id</span><span class="p">)</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이때 새로운 노드를 만든느 <code class="language-plaintext highlighter-rouge">gen_node</code> 함수는 적절히 만들면 된다. 직접 동적
 할당으로 메모리를 잡아도 되고, 문제 풀이 같은 경우는 글로벌 메모리 풀 택틱을
 이용해서 pseudo-alloc을 해줘도 된다.</p>

<h3 id="remove">Remove</h3>

<p>BST에서 노드를 삭제하는 작업은 역시 검색/추가와 비슷하지만, 추가적으로 해야할
 일이 있다. 어떤 노드를 삭제할 때, 매달려 있는 자식이 없는 경우는 그저 노드를
 지우기만 하면 된다. 하지만 그렇지 않은 경우, 삭제할 노드를 <strong>다른 적절한 노드</strong>와
 바꿔줘야 한다. 그래야 검색 성질을 유지할 수 있다. 이때 ‘적절한 노드’란, 검색
 성질을 유지하기 위해서 순서에 맞는 다음 노드이다. 예를 들어 검색 성질이 단순히
 노드 아이디 사이의 대소 비교 less(<code class="language-plaintext highlighter-rouge">&lt;</code>)라면, 지울 노드의 아이디보다 큰 아이디의
 노드들 중 가장 작은 아이디의 노드가 적절한 노드가 될 것이다. 따라서 다음과 같이
 함수를 정의할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">remove</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="c1">// empty tree</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

  <span class="c1">// find the node to remove</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">id</span><span class="p">)</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// id found</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">l</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">r</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// zero or one child only</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">l</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">?</span> <span class="n">r</span> <span class="o">:</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// two children</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">very_next</span> <span class="o">=</span> <span class="n">left_most</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">very_next</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">very_next</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// after remove, tree can be empty</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>지우고자 하는 노드를 찾은 경우, 노드의 자식이 없거나, 하나이거나, 두 개인
 경우를 각각 나눠서 처리한 부분만 주의하면 나머지는 trivial하다. 위의 코드는
 글로벌 메모리 택틱을 사용한 경우에 삭제하는 코드이다. 그래서 두 가지 해킹이
 들어갔는데, (1) 먼저 삭제할 노드의 메모리를 직접적으로 해제하지 않았고, (2) 또
 삭제할 노드의 바로 다음 노드를 가져오는 게 아니라 <code class="language-plaintext highlighter-rouge">id</code> 값을 직접 복사하고 있음을
 알 수 있다. 만약 동적 할당으로 노드를 만든 더 일반적인 구현의 경우에는 (1)과
 (2) 처럼 하면 안되고 조심해서 메모리를 해제하고, 노드의 값을 복사하는게 아니라
 포인터만 옮기는 것이 좋다.</p>

<p>이때 자식이 두 개인 경우 바로 다음 순서의 노드를 구하는 함수는 다음과 같이
 정의할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">left_most</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">cur</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>즉, 오른쪽 서브트리의 가장 왼쪽 노드를 찾으면 된다. 검색 성질을 만족하기
 때문에, 이 함수를 루트를 넘겨서 호출하면 가장 order가 작은 값이 되고, 반대로
 <code class="language-plaintext highlighter-rouge">right_most</code>를 호출하면 가장 order가 큰 값이 된다</p>

<h3 id="traverse">Traverse</h3>

<p>BST는 검색 성질을 만족하기 때문에, root로부터 중위 순회를 하면 그냥 정렬된
 순서가 된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">in_order</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">){</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">in_order</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>  <span class="c1">// visit this node and do something</span>
    <span class="n">in_order</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>다른 두 순회 방법인 pre-order, post-order는 visit의 순서만 달라질 뿐 기본적인
 구조는 in-order와 동일하다.</p>

<h3 id="problem-skewed-tree">Problem: Skewed Tree</h3>

<p>BST는 강력한 자료 구조이지만, 삽입과 삭제의 순서에 따라 트리가 한쪽으로 쏠리는
 (Skewed) 문제가 있다. 예를 들어, BST에 순서대로 3, 4, 2, 1, 5 가 삽입된다면,
 3을 root로 하는 균형적인 트리가 생성될 것이다.</p>

<p><img src="https://sangwoo-joh.github.io/assets/img/balanced.dot.png" alt="tree-1" /></p>

<p>하지만, 1, 2, 3, 4, 5 와 같이 정렬된 순서로 노드가 삽입된다면, 트리의 모양이
 한쪽으로 편향되게 되고 트리의 높이가 <code class="language-plaintext highlighter-rouge">O(N)</code>이 되므로 <code class="language-plaintext highlighter-rouge">O(logN)</code>의 장점을 잃게 된다.</p>

<p><img src="https://sangwoo-joh.github.io/assets/img/skewed.dot.png" alt="skewed" /></p>

<p>이 문제를 해결하기 위한 Self-Balanced BST 중 하나가 바로 AVL Tree이다.</p>

<h2 id="avl-tree">AVL Tree</h2>
<p>AVL의 뜻은 그냥 만든 사람들 이름인 Adelson-Velskii, Landis의 이니셜을 순서대로
 따온 것이다.</p>

<p>기본적인 아이디어는 다음과 같다:</p>
<ol>
  <li>Height-Balance Property: 높이 균형 성질. 트리 내부의 모든 노드에 대하여,
노드의 자식 서브 트리의 높이의 차이가 최대 1인 성질을 말한다.</li>
  <li>임의의 트리가 높이 균형 성질을 만족할 때, 이 트리를 AVL 트리라고 한다.</li>
</ol>

<p>이 성질을 만족하기 위해 두 가지를 다음과 같이 정의한다:</p>
<ul>
  <li>트리의 높이: 트리의 루트 노드로부터 leaf 노드까지의 경로의 길이 중 가장 긴 것</li>
  <li>노드의 높이: 노드로부터 leaf 노드까지의 경로의 길이 중 가장 긴 것</li>
</ul>

<p>이때 null 노드의 길이를 -1로 정의하면, 어떤 노드의 높이는 다음과 같이 정의할 수
 있다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">height</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>AVL 트리에 노드를 삽입/삭제하는 경우, 루트로부터 해당 노드까지의 <strong>경로에 있는
 노드들의 높이만</strong> 바뀌므로, 노드마다 높이를 캐싱하면 효율적인 계산이 가능하다.
 따라서 기본적인 BST에서 AVL 트리로 확장하기 위해 다음과 같이 기본 구조에 높이를
 추가하면 좋다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>높이를 구하는 함수는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">height</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>노드의 높이를 업데이트하여 캐싱하는 함수는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">update_height</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">node</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">height</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">),</span> <span class="n">height</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 균형을 맞추기 위한 밑준비가 끝났다. 그럼 어떻게 균형을 맞출 수 있을까?</p>

<h3 id="rotation">Rotation</h3>
<p>균형이 깨진 트리를 생각해보자.</p>

<p><img src="https://sangwoo-joh.github.io/assets/img/right_skewed.dot.png" alt="right_skewed" /></p>

<p><code class="language-plaintext highlighter-rouge">x</code>의 왼쪽 서브 트리의 높이보다 오른쪽 서브 트리의 높이가 더 큰 상황이다. 편의를
 위해 오른쪽 서브 트리는 서브 트리의 루트(<code class="language-plaintext highlighter-rouge">y</code>)를 표시했다. 또한 이때 서브 트리의
 높이를 살펴보면, <code class="language-plaintext highlighter-rouge">height(A) = k</code> 라고 했을 때, <code class="language-plaintext highlighter-rouge">height(y) = k+2</code> 가 될 것이므로
 <code class="language-plaintext highlighter-rouge">height(B)</code> 또는 <code class="language-plaintext highlighter-rouge">height(C)</code> 가 <code class="language-plaintext highlighter-rouge">k+1</code> 인 경우이다. B, C 모두 <code class="language-plaintext highlighter-rouge">k+1</code>이라고 하자.</p>

<p>이렇게 <code class="language-plaintext highlighter-rouge">x</code>의 오른쪽 균형이 깨진 상황에서 다시 균형을 맞추기 위한 답은 간단하다.
 <code class="language-plaintext highlighter-rouge">x</code>를 기준으로 왼쪽으로 회전하면 된다. 원래 루트인 <code class="language-plaintext highlighter-rouge">x</code>가 회전 후 왼쪽으로 가기
 때문에 왼쪽으로 회전한다고 표현한다. 즉, 잘 회전해서 아래와 같은 트리를 만들면
 된다. 이 연산은 그저 노드의 부모와 자식을 바꾸는 연산이기 때문에 <code class="language-plaintext highlighter-rouge">O(1)</code>만에
 수행 가능하다.</p>

<p><img src="https://sangwoo-joh.github.io/assets/img/right_skewed_rotated.dot.png" alt="right_skewed_left_rotate" /></p>

<p>이렇게 회전을 하고 나면, <code class="language-plaintext highlighter-rouge">x</code>를 기준으로 <code class="language-plaintext highlighter-rouge">height(A) = k, height(B) = k+1</code> 이
 되므로 <code class="language-plaintext highlighter-rouge">x</code>는 균형이 맞고, <code class="language-plaintext highlighter-rouge">y</code>를 기준으로는 <code class="language-plaintext highlighter-rouge">height(x) = max(height(A),
 height(B)) + 1</code> 이므로 <code class="language-plaintext highlighter-rouge">k+2</code>가 되고 <code class="language-plaintext highlighter-rouge">height(C) = k+1</code>이 되므로 모든 서브 트리가
 균형이 맞게 된다.</p>

<p>이를 코드로 나타내면 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">left_rotate</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">B</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>

  <span class="n">y</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>

  <span class="n">update_height</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">update_height</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">x</code>를 기준으로 회전을 하고 나면 루트가 <code class="language-plaintext highlighter-rouge">y</code>로 바뀌기 때문에 <code class="language-plaintext highlighter-rouge">return</code> 할 루트
 노드가 <code class="language-plaintext highlighter-rouge">y</code>로 변하는 것에 주의해야 한다.</p>

<p>왼쪽으로 균형이 치우친 경우는 앞서 설명한 경우의 mirrored image 이므로 다음과
 같이 오른쪽으로 회전하는 함수를 통해 해결할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">right_rotate</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">B</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>

  <span class="n">y</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">B</span><span class="p">;</span>
  <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

  <span class="n">update_height</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="n">update_height</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>역시 루트가 <code class="language-plaintext highlighter-rouge">y</code>에서 <code class="language-plaintext highlighter-rouge">x</code>로 바뀌기 때문에 <code class="language-plaintext highlighter-rouge">return</code> 할 노드가 달라지는 것에
 주의하면 된다.</p>

<p>이제 양쪽 높이가 다른 경우 회전을 통해 다시 균형을 맞출 수 있게 되었다. 하지만
 완벽한 균형을 맞추기 위해서는 한 가지가 더 필요하다.</p>

<h3 id="balance">Balance</h3>

<p>균형이 오른쪽으로 치우친 경우를 좀더 생각해보자. 왼쪽으로 한번만 회전한다고
 균형을 제대로 맞출 수 있을까? 아래와 같은 경우를 생각해보자.</p>

<p><img src="https://sangwoo-joh.github.io/assets/img/rl_skewed.dot.png" alt="rl_skewed" /></p>

<p>이 경우는 <code class="language-plaintext highlighter-rouge">D</code>의 서브트리에서 노드가 삭제되는 경우 발생할 수 있다. 높이를 따져보면
 <code class="language-plaintext highlighter-rouge">height(D)=k</code> 라고 했을 때, <code class="language-plaintext highlighter-rouge">height(y)=k+2</code>, <code class="language-plaintext highlighter-rouge">height(z)=k+3</code>, <code class="language-plaintext highlighter-rouge">height(A)=k+1</code>,
 <code class="language-plaintext highlighter-rouge">height(x)=k+4</code> 인 경우가 있다. 따라서 <code class="language-plaintext highlighter-rouge">x</code>와 <code class="language-plaintext highlighter-rouge">z</code> 모두 균형이 깨져있는 상태이다. <code class="language-plaintext highlighter-rouge">x</code>는
 오른쪽 서브트리가, <code class="language-plaintext highlighter-rouge">z</code>는 왼쪽 서브트리가 균형이 맞지 않는다.</p>

<p><code class="language-plaintext highlighter-rouge">x</code>를 기준으로 오른쪽으로 치우쳐있으므로 왼쪽으로 한번만 회전하면 될 것 같다.
 하지만 왼쪽으로 회전하면 다음과 같이 여전히 균형이 깨진 트리가 나온다.</p>

<p><img src="https://sangwoo-joh.github.io/assets/img/rl_skewed_wrong_rotated.dot.png" alt="rl_skewed_wrong_rotate" /></p>

<p>정말 그럴까? 높이를 확인해보면 <code class="language-plaintext highlighter-rouge">height(D)=k</code>, <code class="language-plaintext highlighter-rouge">height(y)=k+2</code>, <code class="language-plaintext highlighter-rouge">height(A)=k+1</code>,
 <code class="language-plaintext highlighter-rouge">height(x)=k+3</code>, <code class="language-plaintext highlighter-rouge">height(z)=k+4</code> 가 되므로, 여전히 <code class="language-plaintext highlighter-rouge">z</code>의 균형은 깨져 있다.</p>

<p>이런 경우에는 어떻게 해야할까?</p>

<p>정답은 [<strong>두번 회전</strong>]이다. 다만 첫번째 회전을 자식의 균형을 보고 해야 한다.
 처음 트리에서 <code class="language-plaintext highlighter-rouge">x</code>의 오른쪽 자식 노드인 <code class="language-plaintext highlighter-rouge">z</code>를 기준으로 양쪽 높이를 확인하여
 왼쪽으로 치우쳐 있다면, <code class="language-plaintext highlighter-rouge">z</code>를 기준으로 오른쪽으로 한번 회전하면 아래와 같은
 모양이 나온다.</p>

<p><img src="https://sangwoo-joh.github.io/assets/img/rl_skewed_right_rotate_z.dot.png" alt="rl_skewed_rotate_z" /></p>

<p>높이를 따져보면 <code class="language-plaintext highlighter-rouge">height(D)=k</code>, <code class="language-plaintext highlighter-rouge">height(C)=k+1</code> 이므로 <code class="language-plaintext highlighter-rouge">height(z)=k+2</code>,
 <code class="language-plaintext highlighter-rouge">height(B)=k+1</code> 이므로 <code class="language-plaintext highlighter-rouge">height(y)=k+3</code>, <code class="language-plaintext highlighter-rouge">height(A)=k+1</code>, <code class="language-plaintext highlighter-rouge">height(x)=k+4</code> 가
 된다. 즉 한쪽으로만 치우친(원래 루트 노드인 <code class="language-plaintext highlighter-rouge">x</code>만 균형이 깨진), 우리에게 익숙한
 모양을 얻는다. 이상태에서 <code class="language-plaintext highlighter-rouge">x</code>를 기준으로 왼쪽으로 회전하면 아래와 같이 이쁘게
 균형 잡힌 트리를 얻을 수 있다.</p>

<p><img src="https://sangwoo-joh.github.io/assets/img/rl_skewed_left_rotate_x.dot.png" alt="rl_skewed_rotate_x" /></p>

<p>역시 높이를 살펴보면 <code class="language-plaintext highlighter-rouge">height(A)=k+1</code>, <code class="language-plaintext highlighter-rouge">height(B)=k+1</code> 이므로 <code class="language-plaintext highlighter-rouge">x</code>의 균형도 맞고,
 <code class="language-plaintext highlighter-rouge">height(C)=k+1</code>, <code class="language-plaintext highlighter-rouge">height(D)=k</code> 이므로 <code class="language-plaintext highlighter-rouge">z</code>의 균형도 맞고, <code class="language-plaintext highlighter-rouge">height(x)=k+2</code>,
 <code class="language-plaintext highlighter-rouge">height(z)=k+2</code> 이므로 새로운 루트 노드 <code class="language-plaintext highlighter-rouge">y</code>의 균형도 맞는다.</p>

<p>반대쪽으로 치우친 경우는 이 경우의 mirrored image이므로 생략한다.</p>

<p>이제 준비가 끝났다. 양쪽 서브 트리의 높이 차이를 이용해서 균형이 깨진 경우를
 파악하고, 추가적으로 [두번 회전] 해야 하는 경우도 파악하여 균형을 맞추는
 balance 함수를 다음과 같이 정의할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">balance</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">balancing_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">hl</span> <span class="o">=</span> <span class="n">height</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">hr</span> <span class="o">=</span> <span class="n">height</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">hl</span> <span class="o">&gt;</span> <span class="n">hr</span> <span class="o">+</span> <span class="n">balancing_factor</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">l</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">hll</span> <span class="o">=</span> <span class="n">height</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">hlr</span> <span class="o">=</span> <span class="n">height</span><span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hll</span> <span class="o">&lt;</span> <span class="n">hlr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left_rotate</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">right_rotate</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">hr</span> <span class="o">&gt;</span> <span class="n">hl</span> <span class="o">+</span> <span class="n">balancing_factor</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">hrl</span> <span class="o">=</span> <span class="n">height</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">hrr</span> <span class="o">=</span> <span class="n">height</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hrl</span> <span class="o">&gt;</span> <span class="n">hrr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right_rotate</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">left_rotate</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이때 양쪽 서브 트리의 높이의 차를 <code class="language-plaintext highlighter-rouge">balancing_factor</code>로 선언해두면 이 값을
 적절하게 조절할 수 있다. 참고로 OCaml의 <code class="language-plaintext highlighter-rouge">stdlib</code>가 제공하는 Set 모듈은
 <code class="language-plaintext highlighter-rouge">balancing_factor = 2</code>인 <a href="https://github.com/ocaml/ocaml/blob/trunk/stdlib/set.ml#L99">AVL
 Tree</a>를 제공한다.</p>

<h3 id="avl-insert--remove">AVL Insert &amp; Remove</h3>

<p>이렇게 만든 balance 함수를 이용하면 AVL Tree의 삽입/삭제 함수를 다음과 같이
 정의할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Node</span><span class="o">*</span> <span class="nf">insert</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gen_node</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">id</span><span class="p">)</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>

  <span class="n">update_height</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">balance</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Node</span><span class="o">*</span> <span class="nf">remove</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">id</span><span class="p">)</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="c1">// id found</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">l</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="n">r</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">l</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">?</span> <span class="n">r</span> <span class="o">:</span> <span class="n">l</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// two children</span>
      <span class="n">Node</span><span class="o">*</span> <span class="n">very_next</span> <span class="o">=</span> <span class="n">left_most</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">very_next</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">very_next</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>

  <span class="n">update_height</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

  <span class="k">return</span> <span class="nf">balance</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>이전의 BST의 삽입/삭제 로직과 거의 유사하지만, 연산이 끝난 후 (1) 높이를 새로
 계산하여 업데이트해주고 (2) 이렇게 구한 높이를 이용하여 밸런싱을 해서 균형을
 맞춘다.</p>

<p>여기까지가 AVL 트리의 야매 구현의 전부이다. AVL이라는 무시무시한 이름에 비해
 생각보다 순한 내용이었다.</p>

<h2 id="번외-디버깅-잘하기">(번외) 디버깅 잘하기</h2>
<p>트리와 같은 구조적 데이터는 디버깅하기 꽤 까다롭다. 배열이나 리스트의 경우 그냥
 일렬로 쭉 출력해보면 뭘 잘못했는지 알기 쉬운데, 트리는 그림을 그려보지 않으면
 어디가 잘못됐는지 바로 확인하기가 힘들다. pre/in/post-order로 트리를 순회하면서
 출력하여 디버깅하는 방법도 있지만, 이것도 트리의 크기가 커지면 알아보기가
 힘들다. 이런 구조적인 데이터 타입을 디버깅하기 위해 그래프를 그려주는 툴을
 소개한다.</p>

<h3 id="graphviz">Graphviz</h3>
<p>데비안 패키지에서 기본적으로 설치할 수 있는
 <a href="https://graphviz.org">Graphviz</a>라는 프로그램을 쓰면 쉽게 눈으로 확인할 수
 있다. <code class="language-plaintext highlighter-rouge">sudo apt-get install graphviz</code>로 설치할 수 있다. graphviz는 기본적으로
 <code class="language-plaintext highlighter-rouge">*.dot</code> 파일을 입력으로 받아서 그래프를 그린다. 트리를 그리기 위해서 모든
 문법을 알 필요는 없고, 방향성이 있는 digraph를 그리는 방법만 알면 된다. 문법은
 매우 쉽다. <a href="https://graphviz.org/doc/info/lang.html">DOT Language</a>라는 언어로
 작성한다.</p>

<div class="language-dot highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">digraph</span> <span class="o">[</span><span class="nv">graph</span> <span class="nv">name</span><span class="o">]</span><span class="p">{</span>
  <span class="k">node</span> <span class="o">[</span><span class="n">shape</span><span class="p">=</span><span class="nv">ellipse</span><span class="o">]</span><span class="p">;</span>
  <span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="p">;</span>
  <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="p">;</span>
  <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="p">;</span>
  <span class="nv">null0</span> <span class="o">[</span><span class="n">shape</span><span class="p">=</span><span class="nv">point</span><span class="o">]</span><span class="p">;</span>
  <span class="mi">4</span> <span class="o">-&gt;</span> <span class="nv">null0</span><span class="p">;</span>
  <span class="nv">null1</span> <span class="o">[</span><span class="n">shape</span><span class="p">=</span><span class="nv">point</span><span class="o">]</span><span class="p">;</span>
  <span class="mi">4</span> <span class="o">-&gt;</span> <span class="nv">null1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>첫줄에 <code class="language-plaintext highlighter-rouge">digraph</code> 키워드로 해당 dot 파일이 방향성 있는 그래프를 담고 있다고
 알려준다. 트리는 사이클이 없는 방향성이 있는 그래프이므로 이걸로 그릴 수 있다.
 그리고 중괄호 <code class="language-plaintext highlighter-rouge">{}</code> 안에 노드와 엣지 정보를 그려주면 된다. 엣지 정보는 <code class="language-plaintext highlighter-rouge">소스
 노드 -&gt; 싱크 노드</code>로 매우 직관적인 화살표(<code class="language-plaintext highlighter-rouge">-&gt;</code>)를 이용해 그려주면 된다. 이게
 끝이다. 이렇게 그래프의 구조를 dot 파일에 쓰고 나면 <code class="language-plaintext highlighter-rouge">dot -Tpng -O
 [file-name].dot</code> 커맨드로 해당 파일을 png 파일로 뽑아낼 수 있다. 그럼 아래와
 같은 아름다운 트리 구조를 보며 눈으로 디버깅 할 수 있다.</p>

<p><img src="https://sangwoo-joh.github.io/assets/img/initial.dot.png" alt="tree_example" /></p>

<p>그저 노드 정보와 엣지 정보만 알려주면 dot 파일이 최적의 형태로 그래프를
 그려주기 때문에 우리는 어떤 노드가 루트이고 어떤 순서로 방문해야 하는지를 전혀
 신경쓰지 않아도 된다.</p>

<h3 id="print-to-dot">Print to Dot</h3>
<p>dot 파일을 생성하기 위한 코드는 다음과 같다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">aux_null</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">null_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"null"</span> <span class="o">&lt;&lt;</span> <span class="n">null_id</span> <span class="o">&lt;&lt;</span> <span class="s">" [shape=point];</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" -&gt; "</span> <span class="o">&lt;&lt;</span> <span class="s">"null"</span> <span class="o">&lt;&lt;</span> <span class="n">null_id</span> <span class="o">&lt;&lt;</span> <span class="s">";</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="o">++</span><span class="n">null_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">aux_dot</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" -&gt; "</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">";</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">aux_dot</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="nf">aux_null</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" -&gt; "</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">";</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">aux_dot</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="nf">aux_null</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_dot</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">dot</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dot</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">dot</span> <span class="o">&lt;&lt;</span> <span class="s">"digraph avltree{</span><span class="se">\n</span><span class="s">node [shape=ellipse];</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">aux_dot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">dot</span><span class="p">);</span>
    <span class="n">dot</span> <span class="o">&lt;&lt;</span> <span class="s">"}"</span><span class="p">;</span>
    <span class="n">dot</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Unable to open file: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>


<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<br />

<div>
  <script src="https://giscus.app/client.js"
          data-repo="sangwoo-joh/reactions"
          data-repo-id="R_kgDOJFNVQw"
          data-category="Comments"
          data-category-id="DIC_kwDOJFNVQ84CUox9"
          data-mapping="pathname"
          data-strict="1"
          data-reactions-enabled="1"
          data-emit-metadata="0"
          data-input-position="bottom"
          data-theme="light_high_contrast"
          data-lang="ko"
          data-loading="lazy"
          crossorigin="anonymous"
          async>
  </script>
</div>

<br />

      </div>
    </main>

    
    <footer>
  <a href="/feed.xml">rss</a>
  <a href="mailto:work.sangwoo.joh@gmail.com">mail</a>
  <a href="https://www.linkedin.com/in/sangwoo-joh">linkedin</a>
  <a href="https://github.com/sangwoo-joh">github</a>
  <p class="copyright text-muted">Copyright &copy; sangwoo-joh 2023</p>
  <small><a target="_blank" href="https://icons8.com/icons/set/--camel">Camel icon</a> icon by <a target="_blank" href="https://icons8.com">Icons8</a></small>
</footer>

  </body>
</html>
