<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-site-verification" content="fgTBOMeN_sdI4JNBqYTzDwH0458H8AAVbF78jLjwudg" />
  <script type="text/javascript" src="/assets/vendor/moment.min.js"></script>
  <script type="text/javascript" src="/assets/js/site.js"></script>
  <!-- <script src="https://unpkg.com/cursor-effects@latest/dist/browser.js"></script> -->

  <title>
    
      파이썬 데코레이터
    
  </title>

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="파이썬 데코레이터" />
<meta name="author" content="sangwoo-joh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="요즘 파이썬으로 다양한 작업을 하고 있다. 덕분에 동적 타이핑 세계에서만 해볼 수 있는 다양한 짓(?)을 해보고 있는데, 그 중에서도 데코레이터를 유용하게 썼던 경험을 소개해본다." />
<meta property="og:description" content="요즘 파이썬으로 다양한 작업을 하고 있다. 덕분에 동적 타이핑 세계에서만 해볼 수 있는 다양한 짓(?)을 해보고 있는데, 그 중에서도 데코레이터를 유용하게 썼던 경험을 소개해본다." />
<link rel="canonical" href="https://sangwoo-joh.github.io/python-decorators" />
<meta property="og:url" content="https://sangwoo-joh.github.io/python-decorators" />
<meta property="og:site_name" content="Caml Shaving" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-02-24T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="파이썬 데코레이터" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"sangwoo-joh"},"dateModified":"2022-02-24T00:00:00+00:00","datePublished":"2022-02-24T00:00:00+00:00","description":"요즘 파이썬으로 다양한 작업을 하고 있다. 덕분에 동적 타이핑 세계에서만 해볼 수 있는 다양한 짓(?)을 해보고 있는데, 그 중에서도 데코레이터를 유용하게 썼던 경험을 소개해본다.","headline":"파이썬 데코레이터","mainEntityOfPage":{"@type":"WebPage","@id":"https://sangwoo-joh.github.io/python-decorators"},"url":"https://sangwoo-joh.github.io/python-decorators"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="https://sangwoo-joh.github.io/feed.xml" title="Caml Shaving" />

  <link rel="apple-touch-icon" sizes="57x57" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://sangwoo-joh.github.io/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="https://sangwoo-joh.github.io/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://sangwoo-joh.github.io/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="https://sangwoo-joh.github.io/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://sangwoo-joh.github.io/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="https://sangwoo-joh.github.io/assets/icons/manifest.json">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Ubuntu" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Open+Sans" />
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">
  <link rel="stylesheet" href="https://sangwoo-joh.github.io/assets/css/main.css" />
  <link rel="stylesheet" href="https://sangwoo-joh.github.io/assets/css/syntax.css" />
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J0C68FHJ6L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J0C68FHJ6L');
</script>


</head>
<body a="auto">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="https://sangwoo-joh.github.io">/home/caml-shaving</a>
<center>
<h1>파이썬 데코레이터</h1>
<h2></h2>
</center>

<div class="post-edit-date">
  
  2022-02-24
</div>

<div class="post-edit-date">
  
  
</div>

<em><p align="right">

태그:



<a href="/archive?tag=dev"><span class="tag">dev</span></a>





<a href="/archive?tag=python"><span class="tag">python</span></a>




</p></em>


<p>요즘 파이썬으로 다양한 작업을 하고 있다. 덕분에 동적 타이핑
 세계에서만 해볼 수 있는 다양한 짓(?)을 해보고 있는데, 그 중에서도
 데코레이터를 유용하게 썼던 경험을 소개해본다.</p>

<h2 id="파이썬-데코레이터">파이썬 데코레이터</h2>
<p>데코레이터의 생긴 모습 자체는 익숙하다. 자바에도
 <a href="https://en.wikipedia.org/wiki/Java_annotation">어노테이션</a>이라는게
 있긴 한데, 얘는 정적인 용도로 컴파일 타임에 주로 쓰이는 것으로 알고
 있다. 반면 파이썬의 데코레이터는 동적인 환경에서 온갖 다양한 훅을
 구사할 수 있다. 생긴 모습은 다음과 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@decorator</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">@</code>로 시작하는 부분이 함수에 씌여진 데코레이터이다. 적용된 함수의
 <strong>모든 것</strong>을 동적으로 후킹할 수 있는데, 예를 들면</p>
<ul>
  <li>함수가 속한 클래스, 함수 이름</li>
  <li>args와 kwargs를 포함한 모든 함수 아규먼트들</li>
  <li>아예 함수 자체를 호출하지 않거나 두 번 이상 호출할 수도 있다.</li>
</ul>

<p>그러니까 함수의 행동을 동적으로 조작하고 싶을 때 유용한 것으로
 이해했다.</p>

<p>모든 것이 오브젝트로 관리되는 파이썬 세계에서 사실 데코레이터 역시
 <a href="https://www.python.org/dev/peps/pep-0318/#motivation">그냥
 함수</a>다. 그러니까
 위의 코드는 사실 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func_to_wrap</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">func_to_wrap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">closure</span>

<span class="c1"># apply decorator
</span><span class="n">foo</span> <span class="o">=</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</code></pre></div></div>

<p>함수도 오브젝트이므로 파라미터로 넘길 수 있는데(functional?!), 이를
 받아서 원래 함수와 원래 아규먼트를 가지고 다양한 짓을 하는
 클로저(<code class="language-plaintext highlighter-rouge">closure</code>)를 만들어서 리턴하는 함수가 바로
 데코레이터다. 여기서는 그냥 원래 함수를 원래 아규먼트로
 호출했다. <code class="language-plaintext highlighter-rouge">@decorator</code>는 데코레이터를 감싸서 만든 클로저 <code class="language-plaintext highlighter-rouge">foo =
 decorator(foo)</code>를 좀더 읽기 좋게 만들어주는 Syntactic Sugar다.</p>

<p>코드를 보면 알겠지만 <code class="language-plaintext highlighter-rouge">foo</code>에 넘어가는 모든 파라미터들을
 <code class="language-plaintext highlighter-rouge">closure(*args, **kwargs)</code>로 후킹하고 있기 때문에 우리는 이 모든
 파라미터들에 접근할 수 있게 된다.</p>

<h2 id="functoolswraps"><code class="language-plaintext highlighter-rouge">functools.wraps</code></h2>
<p>다만 위와 같이 클로저를 만들어 버리면 한 가지 문제가 생긴다. 원본
 함수 <code class="language-plaintext highlighter-rouge">foo</code>를 받아서 이걸 클로저로 덮어 쓴 함수 오브젝트를 리턴하기
 때문에, 데코레이팅된 <code class="language-plaintext highlighter-rouge">foo</code> 함수 오브젝트를 <code class="language-plaintext highlighter-rouge">print</code>로 찍어보면 이름이
 <code class="language-plaintext highlighter-rouge">foo</code>가 아니라 <code class="language-plaintext highlighter-rouge">closure</code>가 나온다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">function</span> <span class="n">decorator</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">closure</span> <span class="n">at</span> <span class="p">....</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>생각해보면 당연하다. 우리는 원본 <code class="language-plaintext highlighter-rouge">foo</code> 함수를 돌려준게 아니기
 때문이다. 앞에서 모든 것을 후킹할 수 있다고 했는데, 이러면 함수
 이름이나 함수가 속한 클래스를 못찾게 된다. 여기서는 함수 이름을
 예시로 들었지만, 실제로는 원본 함수 오브젝트의 모든 함수 관련
 속성(function attribute), 즉 <code class="language-plaintext highlighter-rouge">__name__</code>, <code class="language-plaintext highlighter-rouge">__dict__</code>, <code class="language-plaintext highlighter-rouge">__qualname__</code>,
 <code class="language-plaintext highlighter-rouge">__code__</code>, <code class="language-plaintext highlighter-rouge">__module__</code>, <code class="language-plaintext highlighter-rouge">__doc__</code> 등을 잃어버리게 된다.</p>

<p>이 문제를 해결해주는 아이가 바로 <code class="language-plaintext highlighter-rouge">functools.wraps</code>이다. 얘는 표준
 라이브러리에 있으니까 맘 편히 쓰면 된다. 사용 방법은 위의 데코레이터
 정의에 다음 한 줄을 추가해주면 된다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">functools</span>

<span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func_to_wrap</span><span class="p">):</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func_to_wrap</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">func_to_wrap</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">closure</span>
</code></pre></div></div>

<p>한마디로 정확한 데코레이터를 만들기 위한 데코레이터다. 뭔가 점점
 게슈탈트 붕괴가 일어나는 듯 하다. 아무튼 얘는 파라미터로 받은 원본
 함수 오브젝트의 모든 메타데이터를 유지해준다. 구체적으로는
 <code class="language-plaintext highlighter-rouge">update_wrapper</code>와 <code class="language-plaintext highlighter-rouge">parital</code> 등 깊은 내부 구현 사항이 있는데 거기까지
 알아야 할 일은 없을 것 같아서 이쯤에서 멈추겠다.</p>

<p>아무튼 <strong>데코레이터를 만들 때는 <code class="language-plaintext highlighter-rouge">functools.wraps</code>로 원본 함수를 한번
 감싸 줘야 함수 속성이 유지된다</strong>는 것만 기억하면 된다.</p>

<h2 id="유용하게-썼던-데코레이터">유용하게 썼던 데코레이터</h2>
<h3 id="타이머">타이머</h3>
<p>먼저 타이머다. 이름 그대로 함수에 타이머를 달아서 수행 시간을 측정할
 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="n">functools</span>

<span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">started</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">finished</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">time_spent</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="nf">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="p">(</span><span class="n">finished</span> <span class="o">-</span> <span class="n">started</span><span class="p">))</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__qualname__</span><span class="si">}</span><span class="s"> took </span><span class="si">{</span><span class="n">time_spent</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">return</span> <span class="n">closure</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">time.time()</code>으로 원본 함수 전후에 틱을 잰다. 단위는 초(second)다.</li>
  <li><code class="language-plaintext highlighter-rouge">datetime.timedelta()</code>로 시간 간격을 읽기 좋은 형태로 바꿔서
출력한다.</li>
  <li><code class="language-plaintext highlighter-rouge">__qualname__</code> 속성으로 수행한 함수 이름(메소드라면 클래스
이름까지) 같이 보여주면 좋다.</li>
  <li>참고로 <code class="language-plaintext highlighter-rouge">*args</code>에 <code class="language-plaintext highlighter-rouge">self</code>까지 같이 넘어오기 때문에, 이거 하나로 일반
함수 및 클래스의 메소드까지 다 적용할 수 있다.</li>
</ul>

<p>여기서 좀더 나가면 <code class="language-plaintext highlighter-rouge">*args</code> 또는 <code class="language-plaintext highlighter-rouge">**kwargs</code>에 특정 타입의 오브젝트가
 넘어온다고 가정하고, 해당 오브젝트의 특정 필드에 함수 수행 시간을
 기록할 수도 있다. 나는 보통 장고의 ORM 오브젝트를 넘겨서
 <code class="language-plaintext highlighter-rouge">time_spent</code>를 저장하기도 했다.</p>

<h3 id="예외-삼키기">예외 삼키기</h3>
<p>많은 API를 호출해서 결과 페이로드를 파싱해야 할 때가 있다. 그런데
 오래 서비스된 API라서 페이로드의 모양이 일정하지 않은 경우가 종종
 있다. 즉, 서버의 버전이 업그레이드되면서 Json의 특정 필드가 <code class="language-plaintext highlighter-rouge">null</code> 인
 경우가 생기는 것이다. 이런 코너 케이스를 모두 일일이 찾아서 그에
 해당하는 디폴트 값을 줘도 되지만, 단순하게 특정 필드가 <code class="language-plaintext highlighter-rouge">null</code>인
 경우를 아예 무시해도 좋은 경우라면 그냥 예외를 삼켜버리면 된다. 보통
 다음 예외가 발생한다:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">TypeError</code>: <code class="language-plaintext highlighter-rouge">null</code> 오브젝트에 인덱스로 접근할 때 발생한다. 즉
<code class="language-plaintext highlighter-rouge">None[1]</code>에서 발생한다.</li>
  <li><code class="language-plaintext highlighter-rouge">KeyError</code>: 오브젝트 자체는 <code class="language-plaintext highlighter-rouge">null</code>이 아니지만 키 값이 없을 때
발생한다. 즉 <code class="language-plaintext highlighter-rouge">{'a': 1}['b']</code>에서 발생한다.</li>
  <li><code class="language-plaintext highlighter-rouge">AttributeError</code>: 속성 자체가 없을 때 발생한다. 예를 들어 어떤
클래스의 인스턴스 <code class="language-plaintext highlighter-rouge">foo</code>에 <code class="language-plaintext highlighter-rouge">foo.a</code>는 있는데 <code class="language-plaintext highlighter-rouge">foo.b</code>는 없으면
발생한다.</li>
</ul>

<p>사실 모든 예외를 싸그리 <code class="language-plaintext highlighter-rouge">Exception</code>으로 잡아서 무시해도 되지만,
 그러면 다른 오류가 난 경우까지 삼켜버리기 때문에 나중에 괴상한 오류를
 만날 수도 있으니 주의해야 한다. 아무튼 이렇게 집어 삼킬 예외를
 정의하고 나면 다음과 같은 데코레이터를 사용할 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">functools</span>

<span class="k">def</span> <span class="nf">swallow_exception</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nf">except </span><span class="p">(</span><span class="nb">TypeError</span><span class="p">,</span> <span class="nb">KeyError</span><span class="p">,</span> <span class="nb">AttributeError</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">return</span> <span class="n">closure</span>
</code></pre></div></div>

<p>별거 없이 <code class="language-plaintext highlighter-rouge">try ... except</code>로 한번 감싸서 원하는 예외만 삼키는
 구조인데, 내가 겪은 것처럼 예외가 여기저기 발생할 수 있어서 여기저기
 <code class="language-plaintext highlighter-rouge">try</code>를 삽입하기 귀찮을 때 유용하게 쓸 수 있다.</p>

<h2 id="데코레이터-적용-순서">데코레이터 적용 순서</h2>
<p>앞에서 데코레이터는 그냥 클로저를 리턴하는 함수라고 했는데, 따라서
 당연히 하나의 함수에 여러 개의 데코레이터를 적용하는 것도
 가능하다. 그리고 파이썬 표준에서는 이렇게 여러 개의 데코레이터가
 적용됐을 때 <a href="https://mail.python.org/pipermail/python-dev/2004-September/048874.html">어떤 순서로
 적용되는지</a>를
 명시하고 있는데, 한마디로 <strong>함수에 가까운 것부터 먼저
 적용</strong>된다. 코드를 위아래로 훑는다고 생각하면 일종의 스택이라고
 생각해도 되겠다. 맨 마지막(아래) 데코레이터부터 적용되니까.</p>

<p>아래와 같이 위의 두 가지 데코레이터를 두 가지 순서로 적용한 경우를
 모두 살펴보자.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># swallow_exception -&gt; timer
</span><span class="nd">@timer</span>
<span class="nd">@swallow_exception</span>
<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="k">raise</span> <span class="nb">TypeError</span>


<span class="c1"># timer -&gt; swallow_exception
</span><span class="nd">@swallow_exception</span>
<span class="nd">@timer</span>
<span class="k">def</span> <span class="nf">baz</span><span class="p">():</span>
    <span class="k">raise</span> <span class="nb">TypeError</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">bar()</code>를 호출하면 <code class="language-plaintext highlighter-rouge">@swallow_exception</code>가 먼저 예외를 삼키고, 그
다음 <code class="language-plaintext highlighter-rouge">@timer</code>가 앞선 모든 동작의 시간을 계산하여 출력한다.</li>
  <li>반면 <code class="language-plaintext highlighter-rouge">baz()</code>를 호출하면 <code class="language-plaintext highlighter-rouge">@timer</code>가 먼저 적용되는데, 예외가 발생하여
시간 계산을 끝내지 못하고 예외를 던져버린다. 그러면
<code class="language-plaintext highlighter-rouge">@swallow_exception</code>이 던져진 예외를 삼키게 되고 결과적으로 아무런
출력이 없다.</li>
</ul>

<hr />

<p>정적 타입과 함수형 프로그래밍 지지자로서 파이썬 관련 글은 피하고
 싶었지만, 파이썬으로 밥 벌어 먹고 살다 보니 이쪽의 경험이 유의미하게
 늘어나고 있고 개중에는 또 재밌고 유용한 것도 있어서 이렇게 기록을
 남기게 되었다. 기왕 이렇게 된 거 종종 파이썬 관련 글도 써봐야겠다.</p>


<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<br />

<div>
  <script src="https://giscus.app/client.js"
          data-repo="sangwoo-joh/reactions"
          data-repo-id="R_kgDOJFNVQw"
          data-category="Comments"
          data-category-id="DIC_kwDOJFNVQ84CUox9"
          data-mapping="pathname"
          data-strict="1"
          data-reactions-enabled="1"
          data-emit-metadata="0"
          data-input-position="bottom"
          data-theme="light_high_contrast"
          data-lang="ko"
          data-loading="lazy"
          crossorigin="anonymous"
          async>
  </script>
</div>

<br />

      </div>
    </main>

    
    <footer>
  <a href="/feed.xml">rss</a>
  <a href="mailto:work.sangwoo.joh@gmail.com">mail</a>
  <a href="https://www.linkedin.com/in/sangwoo-joh">linkedin</a>
  <a href="https://github.com/sangwoo-joh">github</a>
  <p class="copyright text-muted">Copyright &copy; sangwoo-joh 2023</p>
  <small><a target="_blank" href="https://icons8.com/icons/set/--camel">Camel icon</a> icon by <a target="_blank" href="https://icons8.com">Icons8</a></small>
</footer>

  </body>
</html>
